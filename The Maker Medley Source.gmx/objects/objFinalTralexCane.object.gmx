<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprFinalTralexCane</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>spinSpeed = -24;
spinMult = 3;
finalAngle = irandom_range(210, 330);
if ((x &lt; 120 &amp;&amp; finalAngle &lt; 270) || (x &gt; 680 &amp;&amp; finalAngle &gt; 270)){ //reduce chance of them being completely off
    finalAngle = 270 + (270-finalAngle);
}
finalAngleOffset = (spinSpeed * (80 + 20.5));
finalAngleOffset = (abs(finalAngleOffset) mod 360) * sign(finalAngleOffset);
//formula: (spinSpeed * ((spinMult - 1)*denominator + 1 + (denominator-1) / 2)) mod 360

//we're aren't going to move, and we know our final angle, so let's just calculate this now
willCollide = false; //with objFinalP3UndertaleWindow
var _windowX = 55;
var _windowBottom = 481;
if (instance_exists(objFinalP3UndertaleWindow)){
    _windowX = objFinalP3UndertaleWindow.x - 32; //account for 32 pixel border
    _windowBottom = objFinalP3UndertaleWindow.botY+1;
}
image_angle = finalAngle;
if (dsin(finalAngle) != 0){
    var _xCheck = x + lengthdir_x(16, finalAngle);
    var _yDist = (_windowBottom - bbox_bottom);
    var _xDist = _yDist * dcos(finalAngle)/(-dsin(finalAngle));
    if (_xCheck + _xDist &gt;= _windowX &amp;&amp; _xCheck + _xDist &lt;= 800 - _windowX){
        willCollide = true;
    }
}

image_angle = finalAngle - finalAngleOffset;
trailPieceMax = 8;
trailPieces = trailPieceMax;
for (var i=floor(trailPieceMax-1); i &gt;= 0; i--){
    trailAng[i] = image_angle;
    trailX[i] = x;
    trailY[i] = y;
}

movement = 0;
image_alpha = 0;
image_speed = 0;
drawXOff = 0;
drawYOff = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (spinMult &gt; 0){
    image_angle += spinSpeed * min(spinMult, 1);
    spinMult -= 1/40;
}
if (image_alpha &lt; 1){ //must reach 1 before spinMult &lt; 1
    image_alpha += 1/70;
}

if (movement == 0){
    if (spinMult &lt;= 0){
        
    }else{
        if (trailPieces &lt; trailPieceMax)
            trailPieces = min(trailPieces+1, trailPieceMax);
        
        for (i=floor(trailPieceMax-1); i &gt; 0; i--){
            trailAng[i] = trailAng[i-1];
        }
        trailAng[0] = image_angle;
    }
}else if (movement == 1){
    if (bbox_right &lt; 0 || bbox_left &gt; 800 || bbox_top &gt; 608){
        instance_destroy();
    }else{
        if (instance_exists(objFinalP3UndertaleWindow) &amp;&amp; willCollide &amp;&amp; vspeed != 0){
            var _bbox_bottom_precise = y + lengthdir_y(16, finalAngle); //normal bbox_bottom is rounded
            if (_bbox_bottom_precise &lt; objFinalP3UndertaleWindow.botY+1 &amp;&amp; _bbox_bottom_precise+vspeed &gt;= objFinalP3UndertaleWindow.botY+1){ //intersecting the y coordinate of the bottom of the window
                var _yDist = (objFinalP3UndertaleWindow.botY+1 - _bbox_bottom_precise);
                var _xDist = _yDist * hspeed/vspeed;
                y += _yDist;
                x += _xDist;
                speed = 0;
                movement = 2;
            }
        }
    }
    if (trailPieces &lt; trailPieceMax){
        trailPieces = min(trailPieces+1, trailPieceMax);
    }
}else if (movement == 2){
    if (trailPieces &gt; 0){
        trailPieces = max(trailPieces-1, 0);
    }
}else if (movement == 3){
    image_xscale += 0.015;
    image_yscale = image_xscale;
    image_alpha -= 0.055;
    if (image_alpha &lt; 0){
        instance_destroy();
    }else{
        x = xstart + lengthdir_x(16*(image_xscale-1), image_angle + 180);
        y = ystart + lengthdir_y(16*(image_xscale-1), image_angle + 180);
    }
}

if (movement &gt;= 1){
    if (trailPieces &gt; 0){
        for (i=floor(trailPieceMax-1); i &gt; 0; i--){
            trailX[i] = trailX[i-1];
            trailY[i] = trailY[i-1];
        }
        trailX[0] = xprevious;
        trailY[0] = yprevious;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (spinMult &lt;= 0){
    draw_self();
    if (movement &gt;= 1 &amp;&amp; trailPieces &gt;= 1){
        if (trailPieces &gt;= 1){
            var _scale = 1;
            for(var i=floor(trailPieces-1); i &gt;= 0; i -= 1){
                _scale = image_xscale + 3*(i+1)/(trailPieceMax+1);
                draw_sprite_ext(sprite_index, 0, trailX[i] + lengthdir_x(16*(_scale-1), image_angle + 180)  +drawXOff, trailY[i] + lengthdir_y(16*(_scale-1), image_angle + 180)  +drawYOff, _scale, _scale, image_angle, c_white, 1 - (i+1)/(trailPieceMax+1));
            }
        }
    }
}else if (spinMult &lt; 1){
    if (trailPieces &gt;= 1){
        for(var i=trailPieces-1; i &gt;= 0; i -= 0.33){
            draw_sprite_ext(sprite_index, 0, x, y, image_xscale, image_yscale, lerp(trailAng[floor(i)], trailAng[ceil(i)], i mod 1), c_white, 1);
        }
    }
}else{
    draw_set_alpha(image_alpha);
    draw_set_color(c_white);
    draw_circle(x-1, y-1, 16, false);
    draw_set_alpha(1);
}

if (spinMult &lt; 1 &amp;&amp; movement &lt; 2){
    var _xDist = 0;
    var _yDist = 0;
    
    if (willCollide &amp;&amp; instance_exists(objFinalP3UndertaleWindow)){
        _yDist = (objFinalP3UndertaleWindow.botY+1) - y;
        
        if (dsin(finalAngle) != 0){
            _xDist = _yDist * dcos(finalAngle)/(-dsin(finalAngle));
        }
    }else{
        _yDist = 612 - y;
        if (dsin(finalAngle) != 0){
            _xDist = _yDist * dcos(finalAngle)/(-dsin(finalAngle));
        }
    }
    
    draw_set_color(c_white);
    draw_set_alpha((1-spinMult) / 2);
    draw_line_width(x, y, x + _xDist, y + _yDist, 2);
    draw_set_alpha(1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
