<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1300</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>listCol = make_color_rgb(71, 86, 135);
listColSelect = make_color_rgb(87, 102, 150);
listColCircle = make_color_rgb(114, 129, 164);
listColClick = make_color_rgb(63, 67, 117);

playlistCol = make_color_rgb(37, 91, 80);
playlistColSelect = make_color_rgb(42, 104, 91);
playlistColClick = make_color_rgb(30, 73, 64);

inplaylistColCircle = make_color_rgb(67, 102, 117);
inplaylistCol = make_color_rgb(57, 89, 112);
inplaylistColSelect = make_color_rgb(77, 107, 131);
inplaylistColClick = make_color_rgb(44, 65, 81);
//initialize array
totalBoxes = 7;
for(var i=(totalBoxes-1); i&gt;=0; i--){
    shownRoom[i] = 0;
}

listedRoom[global.stageRooms] = 0; 
listedTitle[global.stageRooms] = ""; //let's pretend this will work the way I want it to :)

//this part must be in the order they will appear in, from top to bottom
listedRoom[0] = rOpening; //intro
listedRoom[1] = -1; //playlist
listedRoom[2] = rStage01Abstr4ktNew;
listedRoom[3] = rStage01Dice;
listedRoom[4] = rStage01Kurath;
listedRoom[5] = rStage01Zilily;
listedRoom[6] = rStage01Purify;
listedRoom[7] = rStage01Onetwentyeight;
listedRoom[8] = rStage01Patrick;
listedRoom[9] = rStage01Ace;
listedRoom[10] = rChaozB;
listedRoom[11] = rStage1to2Transition;
listedRoom[12] = -2; //playlist
listedRoom[13] = rStage02Shark1;
listedRoom[14] = rStage02Shark2;
listedRoom[15] = rStage02Erik;
listedRoom[16] = rStage02Klamy;
listedRoom[17] = rStage02Abstr4ktNew;
listedRoom[18] = rStage02Vovka;
listedRoom[19] = rStage02Telejump;
listedRoom[20] = rStage02Flappy;
listedRoom[21] = rGeezer01;
listedRoom[22] = rStage03Hub;
listedRoom[23] = -3; //playlist
listedRoom[24] = rStage04New_1;
listedRoom[25] = rStage04New_2;
listedRoom[26] = rStage04New_3;
listedRoom[27] = rStage04New_4;
listedRoom[28] = rFinalBoss_1;
listedRoom[29] = rTMM_Ending;
listedRoom[30] = rTMM_ClearLobby;

// "Actually they're subtitles"
listedTitle[0] = "";
listedTitle[1] = "Stage 1"; //playlist
listedTitle[2] = "Room 1";
listedTitle[3] = "Room 2";
listedTitle[4] = "Room 3";
listedTitle[5] = "Room 4";
listedTitle[6] = "Room 5";
listedTitle[7] = "Room 6";
listedTitle[8] = "Room 7";
listedTitle[9] = "Room 8";
listedTitle[10] = "Boss";
listedTitle[11] = "";
listedTitle[12] = "Stage 2"; //playlist
listedTitle[13] = "Room 1";
listedTitle[14] = "Room 2";
listedTitle[15] = "Room 3";
listedTitle[16] = "Room 4";
listedTitle[17] = "Room 5";
listedTitle[18] = "Room 6";
listedTitle[19] = "Room 7";
listedTitle[20] = "Room 8";
listedTitle[21] = "Boss";
listedTitle[22] = "Stage 3";
listedTitle[23] = "Stage 4"; //playlist
listedTitle[24] = "Room 1";
listedTitle[25] = "Room 2";
listedTitle[26] = "Room 3";
listedTitle[27] = "Room 4";
listedTitle[28] = "Final Boss";
listedTitle[29] = "Credits";
listedTitle[30] = "Clear Lobby";

playlistOpen[0] = (global.farthestRoom &lt;= scrGetRoomNum(rChaozB));
playlistOpen[1] = (global.farthestRoom &lt;= scrGetRoomNum(rGeezerHitchcock));
//Stage 3 doesn't have a playlist
playlistOpen[2] = (global.farthestRoom &lt;= scrGetRoomNum(rStage04New_4));
for(var i=global.stageRooms;i&gt;=0;i--){
    saveNum[i] = 1;
    inPlaylist[i] = true;
}
inPlaylist[0] = false;
inPlaylist[11] = false;
inPlaylist[22] = false;
inPlaylist[28] = false;
inPlaylist[29] = false;

//rooms with more than one save
saveNum[2] = 3;   //S1 Abstr4kt
saveNum[4] = 2;   //Kurath
saveNum[5] = 2;   //Zilily
saveNum[15] = 3;  //Erik
saveNum[16] = (1 + (global.klamyMax - global.saveKlamySaves));  // Klamy -- Depends on how many times the Player saved
saveNum[17] = 3;  //S2 Abstr4kt
saveNum[18] = 2;  //Vovka
if (global.farthestRoom &gt; scrGetRoomNum(rGeezerHitchcock) || global.roomProgress[scrGetRoomNum(rGeezerHitchcock)] == 2){
    saveNum[21] = 2;  //Geezer+Hitchcock
}
saveNum[22] = 3;  //Stage Rush  -  Convenience
saveNum[24] = 2;  //4-1
saveNum[26] = 3 - global.saveS4KlamySaves; //4-3
saveNum[27] = 2;  //4-4
saveNum[scrGetRoomNum(rFinalBoss_1)] = clamp(global.roomProgress[scrGetRoomNum(rFinalBoss_1)], 1, global.finalBossPhases);  //final boss

/* // I considered ALWAYS having 3 save icons once you reached the S2 Abstr4kt save in 4-3, but ultimately decided against it
if (global.roomProgress[26] == 3){ //reached the save after the Klamy section
    saveNum[26] = 3; //even if the S4Klamy save is left
}*/

menuHeight = 576;
selectedSave = 0;
selectedSavePrev = 0;
numBoxes = 0;
selectedBox = -1;
selectedBoxPrev = -1;
selectedSlot = -1; //0-6
clickedBox = -1;

for(var r = global.stageRooms; r &gt;= 0; r--;){
    for(var s=(global.finalBossPhases-1); s&gt;=0; s--;){ //There must be enough slots for the box with the most saves (final boss)
        saveAng[r, s] = 0; //angle (in radians) of the save's rotation in the level selection menu
        saveScale[r, s] = 1;
    }
}
// Final Boss buffed saves
selectedBuffSave = 0;
selectedBuffSavePrev = 0;
if (!global.gameClearedEver &amp;&amp; max(global.farthestRoom, global.farthestRoomEver) &lt;= scrGetRoomNum(rFinalBoss_1)){
    buffSaveNum[0] = 0;
}else{
    buffSaveNum[0] = min(max(global.finalBossBuffCheckpoint, 0), saveNum[scrGetRoomNum(rFinalBoss_1)], global.finalBossBuffPhases);
}
buffSaveRoom[0] = scrGetRoomNum(rFinalBoss_1);
for(var s=(global.finalBossBuffPhases-1); s&gt;=0; s--;){  // There must be enough slots for the box with the most saves (final boss)
    buffSaveAng[0, s] = 0;  // angle (in radians) of the save's rotation in the level selection menu
    buffSaveScale[0, s] = 1;
}

//scrolling
scrollYPos = 0;
scrollYAmt = 0;
scrollSelected = 0;
scrollClicked = 0; //0 = not clicked; 1 = drag the bar; 2 = move towards the cursor
scrollClickYOff = 0;

//scroll bar
scrollbarWidth = 17;
scrollBarHeight = menuHeight/max(1, (global.farthestRoom/6));
scrollBarY = 0;
scrollbarWidthShown = 0;

event_user(0);
if (global.loadGameMenuStart &gt;= 0 &amp;&amp; global.loadGameMenuStart != rOpening){
    var _startRoomNum = scrGetRoomNum(global.loadGameMenuStart);
    if (_startRoomNum &lt;= 0 || _startRoomNum &gt; global.farthestRoom){
        _startRoomNum = scrGetRoomNum(rOpening);
    }else{  // make the menu automatically scroll down to the row for the screen we were on
        if (global.farthestRoom &gt;= totalBoxes){
            // get starting positiom
            var _stage1Start = scrGetRoomNum(rStage01Abstr4ktNew);
            var _stage1Trans = scrGetRoomNum(rStage1to2Transition);
            var _stage2Start = scrGetRoomNum(rStage02Shark1);
            var _stage3Start = scrGetRoomNum(rStage03Hub);
            var _stage4Start = scrGetRoomNum(rStage04New_1);
            var _finalBStart = scrGetRoomNum(rFinalBoss_1);
            
            playlistOpen[0] = (_startRoomNum &gt;= _stage1Start &amp;&amp; _startRoomNum &lt; _stage1Trans);
            playlistOpen[1] = (_startRoomNum &gt;= _stage2Start &amp;&amp; _startRoomNum &lt; _stage3Start);
            playlistOpen[2] = (_startRoomNum &gt;= _stage4Start &amp;&amp; _startRoomNum &lt; _finalBStart);
            event_user(0);  // recalculate shown boxes
            
            var _pos = _startRoomNum;
            if (!playlistOpen[0] &amp;&amp; _startRoomNum &gt;= _stage1Start){
                _pos -= ((_stage1Trans-1) -_stage1Start) + 1;
            }
            if (!playlistOpen[1] &amp;&amp; _startRoomNum &gt;= _stage2Start){
                _pos -= ((_stage3Start-1)-_stage2Start) + 1;
            }
            if (!playlistOpen[2] &amp;&amp; _startRoomNum &gt;= _stage4Start){
                _pos -= ((_finalBStart-1)-_stage4Start) + 1;
            }

            scrollYPos = clamp(((_pos) / (numBoxes-6)), 0, 1) * (-96*max(0, numBoxes-6));
            scrollBarY = clamp((-scrollYPos) - scrollBarHeight, 0, menuHeight - scrollBarHeight);
        }
    }
}

// make the scrollbar completely visible if we should start with it present
if (numBoxes &gt;= totalBoxes){
    scrollbarWidthShown = 1;
}

// "Delete Save" button
if (global.farthestRoom &gt; 0 &amp;&amp; !instance_exists(objTitleSquareButton)){
    instance_create(800, 545, objTitleSquareButton);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//calculate number of boxes shown
event_user(0);
var _popupFocused = (instance_exists(objPopup) &amp;&amp; (objPopup.y &gt;= 120 || objPopup.move != -1));
var _settingsFocused = (instance_exists(objSettingsMenu) &amp;&amp; (objSettingsMenu.y &lt;= 480 || objSettingsMenu.move != 1));
var _statsFocused = (room != rTMM_ClearLobby &amp;&amp; instance_exists(objStatsDisplay) &amp;&amp; (objStatsDisplay.y &lt;= 480 || objStatsDisplay.move != 1));
var _guiFocused = (_popupFocused || _settingsFocused || _statsFocused);

var _scrollbar = (shownRoom[6] != -1 || numBoxes &gt;= 7);
if (_scrollbar){
    //scroll speed
    if (!_guiFocused &amp;&amp; !instance_exists(objScreenFade)){
        if (mouse_wheel_up() &amp;&amp; mouse_wheel_down()){
            //Do nothing. How/Why would you do this?
        }else if (mouse_wheel_up()){
            if (scrollYAmt &lt; 30){
                scrollYAmt = 30;
            }else if (scrollYAmt &lt; 45){
                scrollYAmt = min(scrollYAmt + 7, 45);
            }
        }else if (mouse_wheel_down()){
            if (scrollYAmt &gt; -30){
                scrollYAmt = -30;
            }else if (scrollYAmt &gt; -45){
                scrollYAmt = max(scrollYAmt - 7, -45);
            }
        }
    }

    scrollbarWidthShown = min(scrollbarWidthShown + 0.2, 1);
    scrollBarHeight = menuHeight/max(1, numBoxes/6);
}else{
    scrollbarWidthShown = max(scrollbarWidthShown - 0.2, 0);
    scrollYAmt = 0;  //reset scroll bar
}

//dragging scroll bar
if (_scrollbar){
    if (((mouse_x &gt;= 688 &amp;&amp; mouse_x &lt; (688 + (scrollbarWidth*scrollbarWidthShown)) &amp;&amp; mouse_y &gt;= 16 &amp;&amp; mouse_y &lt; 16 + 96*6) || scrollClicked == 1)){ //scroll bar
        if (mouse_check_button(mb_left)){
            var _relativeMouseY = (mouse_y - 16);
            var _scrollbarEdge = 3;
            
            //normal scrolling
            if (scrollClicked == 0 &amp;&amp; mouse_check_button_pressed(mb_left)){
                audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
                if (_relativeMouseY &gt;= scrollBarY &amp;&amp; _relativeMouseY &lt; scrollBarY + scrollBarHeight){
                    scrollClicked = 1;
                    scrollClickYOff = scrollBarY - _relativeMouseY;
                }else{
                    scrollClicked = 2;
                }
            }
            if (scrollClicked == 1){
                scrollBarY = _relativeMouseY + scrollClickYOff;
            }else if (scrollClicked == 2){
                if (_relativeMouseY &lt; scrollBarY){
                    scrollBarY = max(_relativeMouseY - _scrollbarEdge, scrollBarY - 8);
                }else if (_relativeMouseY &gt;= (scrollBarY + scrollBarHeight)){
                    scrollBarY = min((_relativeMouseY - _scrollbarEdge) - scrollBarHeight, scrollBarY + 8);
                }
            }
            scrollBarY = clamp(scrollBarY, 0, menuHeight - scrollBarHeight);
            scrollYPos = lerp(0, -96*max(0, numBoxes-6), scrollBarY/(menuHeight-scrollBarHeight));
            scrollYAmt = 0;
        }
        if (scrollSelected == 0){  // don't play select sound if also starting click sound
            audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            scrollSelected = 1;
        }
    }else{
        if (scrollClicked != 0){
            audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
            scrollClicked = 0;
        }
        scrollSelected = 0;
    }
    
    //Scroll if necessary
    if (scrollYAmt != 0){
        scrollYPos += scrollYAmt;
        if (abs(scrollYAmt) &lt;= 5){
            scrollYAmt = 0;
        }else{
            scrollYAmt -= 5*sign(scrollYAmt);
        }
    }
    
    //update the scroll bar's y position
    scrollYPos = clamp(scrollYPos, -96*max(0, numBoxes - 6), 0);
    scrollBarY = (menuHeight - scrollBarHeight) * (-scrollYPos/(96*max(numBoxes - 6, 1)));
}

if (!mouse_check_button(mb_left)){
    scrollClicked = 0;
    scrollClickYOff = 0;
}

var _listIndex;
var _scrollOffset = (scrollYPos mod 96);
if (abs(_scrollOffset) &gt;= 96){ //gamemaker modulo errors
    _scrollOffset = 0;
}

//determine which rooms to show
event_user(1);

//selecting level boxes and save icons
selectedBoxPrev = selectedBox;
selectedSavePrev = selectedSave;
selectedBuffSavePrev = selectedBuffSave;

selectedBox = -1;
selectedSave = 0;
selectedBuffSave = 0;
selectedSlot = -1;

if (!_guiFocused &amp;&amp; !instance_exists(objScreenFade)){
    // selecting box and (normal) saves
    var _saveStartX = 332;
    var _saveWidth = 48;
    if (mouse_x &gt;= 16 &amp;&amp; mouse_x &lt; 688 &amp;&amp; mouse_y &gt;= 16 &amp;&amp; mouse_y &lt; 592){ //level boxes
        for(var i=6; i&gt;=0; i--;){
            if (shownRoom[i] &gt;= 0){
                if (mouse_y &gt;= 96*i + (_scrollOffset) + 16 &amp;&amp; mouse_y &lt; 96*i + (_scrollOffset) + 112){
                    selectedSlot = i;
                    selectedBox = shownRoom[selectedSlot];
                    if (selectedBox &gt; 0){
                        if ((saveNum[shownRoom[i]] != 1 || shownRoom[i] == scrGetRoomNum(rFinalBoss_1)) &amp;&amp; mouse_y &gt;= (scrollYPos mod 96 + 96*selectedSlot + 72) &amp;&amp; mouse_y &lt; (scrollYPos mod 96 + 96*selectedSlot + (72 + 32))){
                            if (floor(mouse_x - _saveStartX) &gt;= 0 &amp;&amp; floor(mouse_x - _saveStartX) &lt; _saveWidth*saveNum[selectedBox]){
                                selectedSave = (floor(mouse_x - _saveStartX) div _saveWidth) + 1;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    
    // selecting buff save icon
    var _saveXOffset = 0, _saveXOffsetMax = 0;
    var _buffRoomIndex = 0;  // system future-proofing
    var _hasBuffedSaves = false;
    if (selectedBox == buffSaveRoom[_buffRoomIndex]){
        _hasBuffedSaves = true;
        if (selectedSave == 0){
            for (var s=1; s&lt;=buffSaveNum[_buffRoomIndex]; s++){
                // hardcoded tweaks
                if (_buffRoomIndex == 0 &amp;&amp; s &gt;= 5){  // use inequalities
                    _saveXOffset = 1;  // in positions, not pixels
                }
            }
            if (mouse_y &gt;= (scrollYPos mod 96 + 96*selectedSlot + 24) &amp;&amp; mouse_y &lt; (scrollYPos mod 96 + 96*selectedSlot + (24 + 32))){
                if (floor(mouse_x - _saveStartX) &gt;= 0){  // &amp;&amp; floor(mouse_x - _saveStartX) &lt; _saveWidth * (buffSaveNum[_buffRoomIndex])){
                    for (var s=1; s&lt;=buffSaveNum[_buffRoomIndex]; s++){
                        _saveXOffset = 0;
                        // hardcoded tweaks
                        if (_buffRoomIndex == 0 &amp;&amp; s &gt;= 5){  // use inequalities
                            _saveXOffset = 1;  // in positions, not pixels
                        }
                        if (floor(mouse_x - _saveStartX) &gt;= _saveWidth * ((s-1) + _saveXOffset) &amp;&amp; floor(mouse_x - _saveStartX) &lt; _saveWidth * (s + _saveXOffset)){
                            selectedBuffSave = s;
                            break;  // end the for loop early
                        }
                    }
                }
            }
        }
    }
    
    // save icon animations
    for (var r=0; r &lt; global.stageRooms; r++;){
        for(var s=1; s&lt;=saveNum[r]; s++;){
            if (selectedBox == r &amp;&amp; (s == selectedSave || (s == 1 &amp;&amp; (!_hasBuffedSaves &amp;&amp; selectedSave == 0 &amp;&amp; listedRoom[selectedBox] != rStage03Hub))) &amp;&amp; (clickedBox == r || clickedBox == -1) &amp;&amp; scrSaveIsUnlocked(r, s)){
                saveAng[r, s-1] -= pi/22;
                if (saveScale[r, s-1] &lt; 1.25)
                    saveScale[r, s-1] = min(1.25, saveScale[r, s-1] + 0.025);
            }else{
                if (saveAng[r, s-1] != 0){
                    if (saveAng[r, s-1] mod pi &gt;= -pi/6)
                        saveAng[r, s-1] = 0;
                    else{
                        saveAng[r, s-1] += (pi/6)*sign(angle_difference((degtorad(-saveAng[r, s-1]) mod 180) - 90, 0));
                    }
                }
                if (saveScale[r, s-1] &gt; 1){
                    saveScale[r, s-1] = max(1, saveScale[r, s-1] - 0.025);
                }
            }
        }
    }
    // buff save icon animations
    for(var s=1; s&lt;=buffSaveNum[_buffRoomIndex]; s++){
        if (s == selectedBuffSave &amp;&amp; (clickedBox == r || clickedBox == -1)){
            buffSaveAng[_buffRoomIndex, s-1] -= pi/22;
            if (buffSaveScale[_buffRoomIndex, s-1] &lt; 1.25){
                buffSaveScale[_buffRoomIndex, s-1] = min(1.25, buffSaveScale[_buffRoomIndex, s-1] + 0.025);
            }
        }else{
            if (buffSaveAng[_buffRoomIndex, s-1] != 0){
                if (buffSaveAng[_buffRoomIndex, s-1] mod pi &gt;= -(pi/6))
                    buffSaveAng[_buffRoomIndex, s-1] = 0;
                else{
                    buffSaveAng[_buffRoomIndex, s-1] += (pi/6)*sign(angle_difference(degtorad(-buffSaveAng[_buffRoomIndex, s-1]) mod 180 - 90, 0));
                }
            }
            if (buffSaveScale[_buffRoomIndex, s-1] &gt; 1){
                buffSaveScale[_buffRoomIndex, s-1] = max(1, buffSaveScale[_buffRoomIndex, s-1] - 0.025);
            }
        }
    }
    
    // clicking
    if (selectedBox != -1){
        if (clickedBox == -1){
            if (mouse_check_button_pressed(mb_left)){
                if (selectedBox &gt;= 0 &amp;&amp; ((selectedSave &lt;= 1) || (saveNum[selectedBox] != 1 &amp;&amp; scrSaveIsUnlocked(selectedBox, selectedSave)) || listedRoom[selectedBox] == rStage03Hub)){  // rStage03Hub is a special case
                    clickedBox = selectedBox;
                    audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
                }else{
                    audio_play_sound_nogroup(sndMakerMenuInvalid, 0, 0);
                }
            }
        }
        if (clickedBox == -1 || clickedBox == selectedBox){  // select SFX
            if (selectedBox != selectedBoxPrev || (selectedSave != 0 &amp;&amp; selectedSave != selectedSavePrev &amp;&amp; scrSaveIsUnlocked(selectedBox, selectedSave)) || (selectedBuffSave != 0 &amp;&amp; selectedBuffSave != selectedBuffSavePrev)){
                audio_stop_sound(sndMakerMenuSelect);
                audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            }
        }
    }
    
    if (clickedBox != -1){
        if (mouse_check_button_released(mb_left) &amp;&amp; clickedBox == selectedBox){  // (selectedSave == 0 || scrSaveIsUnlocked(clickedBox, selectedSave))
            if (listedRoom[clickedBox] &gt;= 0){
                scrStopMusic();
                global.savePlayerX = -100;
                global.savePlayerY = -100;
                global.gameStarted = true;
                
                // override player's default spawn point
                if (listedRoom[clickedBox] == rStage02Klamy){
                    if (selectedSave &gt;= 2){
                        global.savePlayerX = global.klamySaveCoord[selectedSave-2, 0];
                        global.savePlayerY = global.klamySaveCoord[selectedSave-2, 1];
                    }
                }else if (listedRoom[clickedBox] == rStage04New_3){
                    if (selectedSave == 2){
                        if (global.S4KlamySaves == 1){  // this should take you to the third save
                            selectedSave = 3;
                        }else if (global.S4KlamySaves == 0){  // this needs to be set up like S2 Klamy  (what does??? the menu????)
                            global.savePlayerX = global.klamySaveCoord[3, 0];
                            global.savePlayerY = global.klamySaveCoord[3, 1];
                        }
                    }
                }
                
                if (listedRoom[clickedBox] == rStage03Hub &amp;&amp; selectedSave &gt;= 1){
                    selectedSave += 1; // from [1, 3] to [2, 4]
                }
                
                global.roomSaveTo = selectedSave;
                
                scrLoadConfig();
                global.pauseDelay = 2;  // prevent pausing on the first frame, causing the pause screen to show the Load Game menu as the background
                global.practicing = false;  // in case the practice mode management bugged out
                //global.practPrevBoss = -1;  // the player is probably done practicing whatever boss this is  // why???
                scrBackupSave(global.savenum);  // backup the save files
                var _room = listedRoom[clickedBox];
                if (listedRoom[clickedBox] == rFinalBoss_1 &amp;&amp; (selectedSave != 0 || selectedBuffSave != 0)){
                    global.finalStartAtBuffed = (selectedSave &lt;= 0 &amp;&amp; selectedBuffSave &gt; 0);
                    if (global.finalStartAtBuffed){
                        global.roomSaveTo = selectedBuffSave;
                        if (selectedBuffSave &gt;= 5){
                            global.roomSaveTo ++;  // we skip save 5
                        }
                    }
                    switch(global.roomSaveTo){
                        case 1:
                            _room = rFinalBoss_1;
                            break;
                        case 2:
                        case 3:
                            _room = rFinalBoss_2;
                            break;
                        case 4:
                            _room = rFinalBoss_3;
                            break;
                        case 5:  // buffed mode doesn't have the Sudnep autosave
                        case 6:
                            _room = rFinalBoss_4;
                            break;
                    }
                }else if (listedRoom[clickedBox] == rGeezer01 &amp;&amp; selectedSave == 2){
                    global.hitchAutostart = false;
                    _room = rGeezerHitchcock;
                }else{
                    _room = listedRoom[clickedBox];
                }
                
                if (room_exists(_room)){
                    scrLoadGame(false, _room);
                    //show_debug_message("Save: " + string(selectedSave) + " ;Buffed Save: " + string(selectedBuffSave));
                }
            }else{
                if (listedRoom[clickedBox] == -1 || listedRoom[clickedBox] == -2 || listedRoom[clickedBox] == -3){
                    var _playlist = (abs(listedRoom[clickedBox]) - 1);  //0-2
                    playlistOpen[_playlist] = !playlistOpen[_playlist];
                }
                
                //redetermine number of boxes and which rooms to show
                event_user(0);
                
                //fix the scroll bar
                scrollYPos = clamp(scrollYPos, -96*max(0, numBoxes - 6), 0);
                scrollBarY = (menuHeight - scrollBarHeight) * (-scrollYPos/(96*max(numBoxes - 6, 1)));
                
                event_user(1);
                
                _scrollOffset = (scrollYPos mod 96);
                if (abs(_scrollOffset) &gt;= 96){ //gamemaker modulo errors
                    _scrollOffset = 0;
                }
                clickedBox = -1;
            }
            audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
        }else if (!mouse_check_button(mb_left)){
            clickedBox = -1;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///determine which rooms to show
var _listIndex, _startingBox;
_listIndex = 0;
_startingBox = -(scrollYPos div 96);

var _stage1Start = scrGetRoomNum(rStage01Abstr4ktNew);
var _stage1Trans = scrGetRoomNum(rStage1to2Transition);
var _stage2Start = scrGetRoomNum(rStage02Shark1);
var _stage3Start = scrGetRoomNum(rStage03Hub);
var _stage4Start = scrGetRoomNum(rStage04New_1);
var _finalBStart = scrGetRoomNum(rFinalBoss_1);

if (!playlistOpen[0] &amp;&amp; _startingBox &gt;= _stage1Start){
    _startingBox += ((_stage1Trans-1) -_stage1Start) + 1;
}
if (!playlistOpen[1] &amp;&amp; _startingBox &gt;= _stage2Start){
    _startingBox += ((_stage3Start-1)-_stage2Start) + 1;
}
if (!playlistOpen[2] &amp;&amp; _startingBox &gt;= _stage4Start){
    _startingBox += ((_finalBStart-1)-_stage4Start) + 1;
}

for(var i = _startingBox; _listIndex &lt; 7 &amp;&amp; i &lt;= max(global.farthestRoom, 0); i++;){
    if (i == 0 || (listedRoom[i] &lt; 0 &amp;&amp; i+1 &lt;= global.farthestRoom) || (playlistOpen[0] &amp;&amp; i &gt;= _stage1Start &amp;&amp; i &lt; _stage1Trans) || i == _stage1Trans || (playlistOpen[1] &amp;&amp; i &gt;= _stage2Start &amp;&amp; i &lt; _stage3Start) || i == _stage3Start || (playlistOpen[2] &amp;&amp; i &gt;= _stage4Start &amp;&amp; i &lt; _finalBStart) || i &gt;= _finalBStart){
        shownRoom[_listIndex] = i;
        _listIndex ++;
    }
}

for (var i = _listIndex; i &lt; 7; i++){
    shownRoom[i] = -1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///calculate number of boxes present
numBoxes = 0;
var _stage1Start = scrGetRoomNum(rStage01Abstr4ktNew);
var _stage1Trans = scrGetRoomNum(rStage1to2Transition);
var _stage2Start = scrGetRoomNum(rStage02Shark1);
var _stage3Start = scrGetRoomNum(rStage03Hub);
var _stage4Start = scrGetRoomNum(rStage04New_1);
var _finalBStart = scrGetRoomNum(rFinalBoss_1);

for(var i = 0; i &lt;= max(global.farthestRoom, 0); i ++){
    if (i == 0 || (listedRoom[i] &lt; 0 &amp;&amp; i+1 &lt;= global.farthestRoom) || (playlistOpen[0] &amp;&amp; i &gt;= _stage1Start &amp;&amp; i &lt; _stage1Trans) || i == _stage1Trans || (playlistOpen[1] &amp;&amp; i &gt;= _stage2Start &amp;&amp; i &lt; _stage3Start) || i == _stage3Start || (playlistOpen[2] &amp;&amp; i &gt;= _stage4Start &amp;&amp; i &lt; _finalBStart) || i &gt;= _finalBStart){
        numBoxes += 1;
    }
}

//scrollBarHeight = menuHeight/max(1, numBoxes/6);  // only update scrollBarHeight when the player can scroll
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, _scrollOffset;
_scrollOffset = (scrollYPos mod 96);
if (abs(_scrollOffset) &gt;= 96){ //gamemaker modulo errors
    _scrollOffset = 0;
}
var _saveProgress = max(global.farthestRoom, 0);

if (!surface_exists(global.sharedSurf)){
    global.sharedSurf = surface_create(800, 608);
}
if (surface_exists(global.sharedSurf)){
    var _surfaceWidth = 672 + (scrollbarWidth*scrollbarWidthShown);
    var _surfHeight = min(menuHeight, 96*numBoxes);
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(c_black, 0);
    
    //color the boxes
    draw_set_color(inplaylistCol);
    draw_rectangle(0, 0, 671, _surfHeight - 1, false); //background will be the unselected (inside playlist) box
    //color in the selected box, if there is one
    if (selectedBox &gt;= 0){
        if ((clickedBox == -1 || clickedBox != selectedBox) &amp;&amp; shownRoom[selectedSlot] &gt;= 0 &amp;&amp; listedRoom[shownRoom[selectedSlot]] &gt;= 0){
            if (inPlaylist[shownRoom[selectedSlot]]){
                draw_set_color(inplaylistColSelect);
            }else{
                draw_set_color(listColSelect);
            }
            draw_rectangle(-0.5, _scrollOffset + 96*selectedSlot, 672-0.5, _scrollOffset + 96*(selectedSlot+1), false);
        }else if ((clickedBox != -1 &amp;&amp; clickedBox == selectedBox) &amp;&amp; shownRoom[selectedSlot] &gt;= 0 &amp;&amp; listedRoom[shownRoom[selectedSlot]] &gt;= 0){
            if (inPlaylist[shownRoom[selectedSlot]]){
                draw_set_color(inplaylistColClick);
            }else{
                draw_set_color(listColClick);
            }
            draw_rectangle(-0.5, _scrollOffset + 96*selectedSlot, 672-0.5, _scrollOffset + 96*(selectedSlot+1), false);
        }
    }
    
    for(var i=0; i&lt;min(numBoxes, 7); i++){
        if (shownRoom[i] &gt;= 0 &amp;&amp; !inPlaylist[shownRoom[i]] &amp;&amp; selectedBox != shownRoom[i]){
            draw_set_color(listCol);
            draw_rectangle(-0.5, _scrollOffset + 96*i, 672-0.5, _scrollOffset + 96*(i+1), false);
            draw_set_color(c_white);
        }
    }
    
    //playlist boxes will be colored in when their text is drawn
    draw_set_color(c_white);
    var t_boxHeight, t_makerSpr, _color, _listPercent;
    t_boxHeight = _scrollOffset;
    t_makerSpr = 0;
    _color = c_white;
    _listPercent = 0;
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_font(fDefault12);
    
    //Circles
    for(var i=0; i&lt;min(numBoxes, 7); i++){
        if (shownRoom[i] &gt;= 0 &amp;&amp; listedRoom[shownRoom[i]] &gt;= 0 &amp;&amp; (listedRoom[shownRoom[i]] != rOpening &amp;&amp; listedRoom[shownRoom[i]] != rStage1to2Transition &amp;&amp; listedRoom[shownRoom[i]] != rFinalBoss_1 &amp;&amp; listedRoom[shownRoom[i]] != rTMM_Ending)){
            draw_set_color(inplaylistColCircle);
            draw_circle(641, 33 + _scrollOffset + 96*i, 25, false);
            draw_set_color(listColCircle);
            draw_circle(641, 33 + _scrollOffset + 96*i, 25, false);
            draw_set_color(listColClick);
            draw_circle(641, 33 + _scrollOffset + 96*i, 25, true);
            draw_set_color(c_white);
        }
    }
    
    //Text, Saves, &amp; Makers
    var _saveIndex = 0;
    for(var i=0; i&lt;min(7, numBoxes); i++){
        if (shownRoom[i] &gt;= 0 &amp;&amp; listedRoom[shownRoom[i]] &gt;= 0){
            var _roomID = listedRoom[shownRoom[i]];
            draw_sprite(sprTitleStageIcon, scrGetRoomInfo(_roomID, 3), 0, 96*i + (_scrollOffset));
            
            if (_roomID == rStage03Hub){  // special case due to portraits
                var _baseIndex = 31;
                if (global.SRCoin[0] &amp;&amp; global.SRCoin[1] &amp;&amp; global.SRCoin[2]){
                    draw_sprite(sprTitleStageIcon, _baseIndex, 0, 96*i + (_scrollOffset));
                }else{
                    for (var j=0; j&lt;global.totalSRCoins; j++){
                        if (global.SRCoin[j]){
                            draw_sprite(sprTitleStageIcon, (_baseIndex+1)+j, 0, 96*i + (_scrollOffset));
                        }
                    }
                }
            }
            
            //text
            scrDrawTextOutline(138, t_boxHeight + 22, scrGetRoomInfo(_roomID, 0), c_white, c_black);
            scrDrawTextOutline(138, t_boxHeight + 66, listedTitle[shownRoom[i]], c_white, c_black);
            draw_set_halign(fa_right);
            scrDrawTextOutline(602, t_boxHeight + 22, scrGetRoomInfo(_roomID, 1), c_white, c_black);
            draw_set_halign(fa_left);
            
            //saves
            if (shownRoom[i] &gt;= 0 &amp;&amp; (saveNum[shownRoom[i]] != 1 || shownRoom[i] == scrGetRoomNum(rFinalBoss_1))){
                for(var s=1; s&lt;=saveNum[shownRoom[i]]; s++){
                    if (scrSaveIsUnlocked(shownRoom[i], s)){
                        if (shownRoom[i] == scrGetRoomNum(rGeezerHitchcock) || shownRoom[i] == scrGetRoomNum(rFinalBoss_1)){  // hardcoded tweak
                            _saveIndex = 7;
                        }else{
                            _saveIndex = 2;
                        }
                    }else{
                        _saveIndex = 0;
                    }
                    
                    if (clickedBox != -1 &amp;&amp; shownRoom[i] == clickedBox &amp;&amp; clickedBox == selectedBox &amp;&amp; (((s == selectedSave || (s == 1 &amp;&amp; (selectedSave == 0 &amp;&amp; selectedBuffSave == 0 &amp;&amp; listedRoom[shownRoom[i]] != rStage03Hub))) &amp;&amp; (selectedSave &lt;= global.roomProgress[i] || i &lt; _saveProgress)))){
                        _color = c_gray;
                    }else{
                        _color = c_white;
                    }
                    
                    draw_sprite_ext(sprMakerSave, _saveIndex, 340 + 48*(s-1), t_boxHeight + 72, saveScale[shownRoom[i], s-1], saveScale[shownRoom[i], s-1], 22*sin(saveAng[shownRoom[i], s-1]), _color, 1);
                }
            }
            
            // buffed checkpoints
            var _buffRoomIndex = 0;
            var _saveXOffset = 0;
            if (shownRoom[i] == buffSaveRoom[_buffRoomIndex]){
                for(var s=1; s&lt;=buffSaveNum[_buffRoomIndex]; s++){
                    if (_buffRoomIndex == 0 &amp;&amp; s &gt;= 5){  // use inequalities
                        _saveXOffset = 1;  // in positions, not pixels
                        if (s == 5){
                            draw_sprite(sprLoadGameBuffSaveEmpty, 0, 340 + 48*(s-1), t_boxHeight + 24 + 2);
                        }
                    }
                    _saveIndex = 17;
                    
                    if (clickedBox != -1 &amp;&amp; shownRoom[i] == clickedBox &amp;&amp; clickedBox == selectedBox &amp;&amp; s == selectedBuffSave){
                        _color = c_gray;
                    }else{
                        _color = c_white;
                    }
                    
                    draw_sprite_ext(sprMakerSave, _saveIndex, 340 + 48*((s+_saveXOffset)-1), t_boxHeight + 24, buffSaveScale[_buffRoomIndex, s-1], buffSaveScale[_buffRoomIndex, s-1], 22*sin(buffSaveAng[_buffRoomIndex, s-1]), _color, 1);
                }
            }
            
            t_makerSpr = scrGetRoomInfo(_roomID, 2);
            if (t_makerSpr &gt;= 0){
                draw_sprite(sprTitleMakers, t_makerSpr, 641, t_boxHeight + 33);
            }else if (t_makerSpr == -2){
                draw_sprite(sprMakerTitleMedleyIcon, 0, 642, t_boxHeight + 34);
            }else if (t_makerSpr == -3){
                //draw_sprite(sprMakerTitleElephantIcon, 0, 642, t_boxHeight + 34);  // Removed to make room for "buff" saves
            }
        }else if (shownRoom[i] &gt;= 0){ //playlists
            //color in the box
            if (shownRoom[i] == selectedBox){
                if (shownRoom[i] == clickedBox){
                    draw_set_color(playlistColClick);
                }else{
                    draw_set_color(playlistColSelect);
                }
            }else{
                draw_set_color(playlistCol);
            }
            
            draw_rectangle(0, _scrollOffset + i*96, 671, _scrollOffset + i*96 + 95, false);
            draw_set_color(c_white);
            
            //write the playlist title and subtitle
            var _title = "";
            switch(listedRoom[shownRoom[i]]){
                case -1:
                    _title = "Royalty-Free Safe Space";
                break;
                case -2:
                    _title = "Not Another NANG Clone";
                break;
                case -3:
                    _title = "Fractured Flashbacks";
                break;
            }
            scrDrawTextOutline(138, t_boxHeight + 22, _title, c_white, c_black);  //title
            scrDrawTextOutline(138, t_boxHeight + 66, listedTitle[shownRoom[i]], c_white, c_black);  //subtitle
        }
        t_boxHeight += 96;
    }
    
    draw_set_font(fFlappyCounter);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    //calculate and draw % completion in playlists
    var _stage1Start = scrGetRoomNum(rStage01Abstr4ktNew);
    var _stage1End = scrGetRoomNum(rChaozB);
    var _stage2Start = scrGetRoomNum(rStage02Shark1);
    var _stage2End = scrGetRoomNum(rGeezer01);
    var _stage4Start = scrGetRoomNum(rStage04New_1);
    var _stage4End = scrGetRoomNum(rStage04New_4);
    for(var i=0; i&lt;7; i++){
        if (shownRoom[i] &gt;= 0 &amp;&amp; listedRoom[shownRoom[i]] &lt; 0){
            _listPercent = 0;
            if (listedRoom[shownRoom[i]] == -1){
                if (_saveProgress &gt; _stage1End){
                    _listPercent = 100;
                }else{
                    var _partialCompletion = 0;
                    if (saveNum[_saveProgress] &gt; 1 &amp;&amp; global.roomProgress[_saveProgress] &gt; 1){
                        _partialCompletion = (global.roomProgress[_saveProgress]-1) / (saveNum[_saveProgress]);
                    }
                    _listPercent = ((_saveProgress-_stage1Start + _partialCompletion)/((_stage1End - _stage1Start) + 1))*100;
                }
            }else if (listedRoom[shownRoom[i]] == -2){
                if (_saveProgress &gt; _stage2End){
                    _listPercent = 100;
                }else{
                    var _partialCompletion = 0;
                    if (saveNum[_saveProgress] &gt; 1 &amp;&amp; global.roomProgress[_saveProgress] &gt; 1){
                        _partialCompletion = (global.roomProgress[_saveProgress]-1) / (saveNum[_saveProgress]);
                    }
                    _listPercent = ((_saveProgress-_stage2Start + _partialCompletion)/(_stage2End - _stage2Start + 1))*100;
                }
            }else if (listedRoom[shownRoom[i]] == -3){
                if (_saveProgress &gt; _stage4End){
                    _listPercent = 100;
                }else{
                    var _partialCompletion = 0;
                    if (saveNum[_saveProgress] &gt; 1 &amp;&amp; global.roomProgress[_saveProgress] &gt; 1){
                        _partialCompletion = (global.roomProgress[_saveProgress]-1) / (saveNum[_saveProgress]);
                    }
                    _listPercent = ((_saveProgress-_stage4Start + _partialCompletion)/(_stage4End - _stage4Start + 1))*100;
                }
            }
            _listPercent = string(_listPercent);
            if (string_length(_listPercent) &gt;= 4 &amp;&amp; string_char_at(_listPercent, 5) == "0"){
                _listPercent = string_copy(_listPercent, 0, string_length(_listPercent)-1);
            }
            
            draw_set_color(c_dkgray);
            draw_rectangle(0, _scrollOffset + i*96, 126, _scrollOffset + i*96 + 95, false);
            
            draw_set_color(c_white);
            draw_text_transformed_outline(66, _scrollOffset + 96*i + 48, _listPercent + "%", 4, c_black, 8, 0.6, 0.6, 0);
        }
    }
    
    //Dividers
    draw_set_color(c_black);
    for(var i=1; i&lt;min(numBoxes, 7); i++){
        draw_line(0, (_scrollOffset) + 96*i - 0.5, 672, (_scrollOffset) + 96*i - 0.5);
    }
    draw_line(127, 0, 127, _surfHeight);
    
    /* //is this necessary?
    draw_set_colour_write_enable(false, false, false, true);
    draw_rectangle(0, 0, 672, _surfHeight, false);
    draw_set_colour_write_enable(true, true, true, true);
    */
    
    //Scroll bar
    if (scrollbarWidthShown &gt; 0){
        //Container
        draw_set_color(listColClick);
        draw_rectangle(672, 0, 688, _surfHeight-1, false);
        draw_set_color(c_black);
        draw_line(672, 0, 672, _surfHeight - .5);
        draw_set_color(c_white);
        
        //Bar
        var _scrollInd;
        if (scrollClicked != 0){
            _scrollInd = 2;
        }else if (scrollSelected != 0){
            _scrollInd = 1;
        }else{
            _scrollInd = 0;
        }
        
        var _drawnBarHeight = min(scrollBarHeight, _surfHeight);
        draw_sprite(sprMakerTitleScrollbar, _scrollInd*3, 673, 1 + scrollBarY);
        draw_sprite_stretched(sprMakerTitleScrollbar, _scrollInd*3 + 1, 673, 8 + scrollBarY, 16, (_drawnBarHeight - 16));
        draw_sprite(sprMakerTitleScrollbar, _scrollInd*3 + 2, 673, 0 + scrollBarY + _drawnBarHeight - 8);
        draw_sprite(sprMakerTitleScrollbar2, _scrollInd, 673, 0 + scrollBarY + roundSane(_drawnBarHeight/2) - 17);
    }
    surface_reset_target();
    
    //draw the list surface
    if (surface_exists(global.sharedSurf)){
        draw_surface_part(global.sharedSurf, 0, 0, _surfaceWidth, _surfHeight+1, 16, 16);
        
        //surface outline
        draw_set_color(c_black);
        draw_rectangle(16, 16  -0.5, (16+_surfaceWidth)  +0.5, _surfHeight+16  + 0.5, true);
        draw_rectangle(17, 17  -0.5, (16+_surfaceWidth)  -0.5, _surfHeight+16  - 0.5, true);
        draw_set_color(c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
