<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprMakerCamera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-8</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>rainbowObjectSurf = noone;
rainbowBKTileSurf = noone;
if (instance_number(object_index) &gt; 1){
    instance_destroy();
}
drawXOff = 0;
drawYOff = 0;

tile_layer_hide(-5);  // for shader failsafe
tile_layer_hide(-7);  // for shader failsafe
tile_layer_hide(1001);  // for shader failsafe
tile_layer_hide(1002);  // for shader failsafe
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(rainbowObjectSurf))
    surface_free(rainbowObjectSurf);
if (surface_exists(rainbowBKTileSurf))
    surface_free(rainbowBKTileSurf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Background Tiles
var _useShader = (global.hueshiftEnabled);

if (!surface_exists(rainbowBKTileSurf)){
    if (room == rStage02Abstr4ktNew){
        rainbowBKTileSurf = surface_create(800, 608);
    }else if (room == rStage04New_3){
        rainbowBKTileSurf = surface_create(704, 192);
    }else if (room == rStage04New_4){
        rainbowBKTileSurf = surface_create(272, 192);
    }
    if (surface_exists(rainbowBKTileSurf)){
        surface_set_target(rainbowBKTileSurf);
        draw_clear_alpha(c_black, 0);
        
        with (objMakerSpikeUp){
            if (spikeIndex == 12){ //abstr4kt 2 spike
                if (!_useShader){
                    spikeIndex = 0;
                }
                event_perform(ev_draw, 0);
                spikeIndex = 12;
            }
        }
        
        var _tileset = tlS2Abstr4ktBack;
        if (_useShader){
            scrDrawRoomTiles(1001, 0, 0, 800, 608, 16);
            draw_background_part(_tileset, 32, 44, 32, 8, 320, 408);
        }else{
            scrDrawRoomTiles(1002, 0, 0, 800, 608, 16);
            draw_background_part(_tileset, 64, 44, 32, 8, 320, 408);
        }
        draw_background_part(_tileset, 0, 44, 32, 8, 288, 408);
        draw_background_part(_tileset, 0, 44, 32, 8, 352, 408);
        surface_reset_target();
    }
}
if (surface_exists(rainbowBKTileSurf)){
    //color spikes and blocks
    if (_useShader){
        shader_set(shdHueShift);
        shader_set_uniform_f(global.hueshiftHandle, 2*pi * global.count/400);
        draw_surface(rainbowBKTileSurf, drawXOff, drawYOff);
        shader_reset();
    }else{
        draw_surface(rainbowBKTileSurf, drawXOff, drawYOff);
        draw_surface_ext(rainbowBKTileSurf, drawXOff, drawYOff, 1, 1, 0, make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225), 0.3);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_destroy, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw background
var _useShader = (global.hueshiftEnabled);
var _col = c_white;
var _background = bkMakerSky;

if (_useShader){
    shader_set(shdHueShift);
    shader_set_uniform_f(global.hueshiftHandle, 2*pi * global.count/400);
    _background = bkS2Abstr4ktNew;
}else{
    _col = make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225);
    _background = bkS2Abstr4ktShaderFailsafe;
}

draw_set_color(c_white);
if (room == rStage02Abstr4ktNew){
    draw_rectangle(0-0.5, 0-0.5, 800-0.5, 608-0.5, false);
    scrDrawTiledAreaExt(_background, global.count mod 256, 0, 0, 0, 800, 608, 1, 1, _col, 1);
}else if (room == rStage04New_3){
    draw_rectangle(64-0.5, 0-0.5, 704-0.5, 184-0.5, false);
    scrDrawTiledAreaExt(_background, global.count mod 256, 0, 64, 0, 704, 184, 1, 1, _col, 1);
}else if (room == rStage04New_4){
    draw_rectangle(64-0.5, 0-0.5, 272-0.5, 184-0.5, false);
    scrDrawTiledAreaExt(_background, global.count mod 256, 0, 64, 0, 272, 184, 1, 1, _col, 1);
}

if (_useShader){
    shader_reset();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//create mask for spikes and blocks
var _useShader = (global.hueshiftEnabled);

if (!surface_exists(rainbowObjectSurf)){
    if (room == rStage02Abstr4ktNew)
        rainbowObjectSurf = surface_create(800, 608);
    else if (room == rStage04New_3)
        rainbowObjectSurf = surface_create(704, 192);
    else if (room == rStage04New_4)
        rainbowObjectSurf = surface_create(272, 192);
    if (surface_exists(rainbowObjectSurf)){
        surface_set_target(rainbowObjectSurf);
        draw_clear_alpha(c_black, 0);
        
        with (objMakerSpikeUp){
            if (spikeIndex == 12){ //abstr4kt 2 spike
                if (!_useShader){
                    spikeIndex = 0;
                }
                event_perform(ev_draw, 0);
                spikeIndex = 12;
            }
        }
        
        var _tileset = tlS2Abstr4kt;
        if (_useShader){
            scrDrawRoomTiles(-5, 0, 0, 800, 608, 16);
            draw_background_part(_tileset, 32, 44, 32, 8, 320, 408);
        }else{
            scrDrawRoomTiles(-7, 0, 0, 800, 608, 16);
            draw_background_part(_tileset, 64, 44, 32, 8, 320, 408);
            _tileset = tlS2SharkBlocks;
        }
        draw_background_part(_tileset, 0, 44, 32, 8, 288, 408);
        draw_background_part(_tileset, 0, 44, 32, 8, 352, 408);
        surface_reset_target();
    }
}
if (surface_exists(rainbowObjectSurf)){
    //color spikes and blocks
    if (_useShader){
        shader_set(shdHueShift);
        shader_set_uniform_f(global.hueshiftHandle, 2*pi * global.count/400);
        draw_surface(rainbowObjectSurf, drawXOff, drawYOff);
        shader_reset();
    }else{
        draw_surface(rainbowObjectSurf, drawXOff, drawYOff);
        draw_surface_ext(rainbowObjectSurf, drawXOff, drawYOff, 1, 1, 0, make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225), 0.3);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
