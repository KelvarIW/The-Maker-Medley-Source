<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprCamera</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-6</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>tilesetDrawing = 17;
tilesetPrevTracking = 8;
for (var i=(tilesetPrevTracking-1); i&gt;=0; i--){
    tilesetPrev[i] = -1;
}

drawXOff = 0;
drawYOff = 0;

creditsScrollHeight = 0; // **SUBTRACT** this from everything that should scroll up
creditsScrollSpd = 0;

// used in scrCreditsDraw();
relativeSpacing = 0;
startDrawing = false;
stopDrawing = false;

//Level-specific
zililyCol = make_color_rgb(0, 2, 4);
sharkGray = make_color_rgb(78, 78, 78);
hitchcockCol = make_color_rgb(77, 143, 185);
vovkaCol = make_color_rgb(87, 87, 87);
patrickFailsafeCol = make_colour_rgb(0, 144, 255);
timer = 0;
timerPrecise = timer;
timerPrev = timer;

//Initial fade-in
fadeTimer = 400;
fadeTimerInit = fadeTimer;
global.canRestart = false;

//tiles
tileState = 0;
tileStateCounterThreshold = 0;
tileStateCounter = 0;
tileState1_Background = -1;

//optimization
tileSurf = -4;
reload = true;

//scrambling (state 1)
for (var j=3; j&gt;=0; j--){
    for (var i=24; i&gt;=0; i--){
        tilesH[j, i] = 0;     //top and bottom (+ corners)
    }
}
for (var i=3; i&gt;=0; i--){
    for (var j=14; j&gt;=0; j--){
        tilesV[j, i] = 0;  // left and right
    }
}
for (var i=18; i&gt;=0; i--){
    spikesH[1, i] = 0;     //bottom
    spikesH[0, i] = 0;     //top
}
for (var i=12; i&gt;=0; i--){
    spikesV[1, i] = 0;     //right
    spikesV[0, i] = 0;     //left
}

//column movement (state 2)
columnNum = 28;  // columns fill 2 rows to the left  (requiring 27 indexes)  +  one extra to the right for transition  (bringing the total to 28)
for (var i=(columnNum-1); i&gt;=0; i--){
    tileColumns[i] = -1;     // state 2
}
//tileColumnFarthest = -1; //index in array
tileColumnFarthest = (columnNum-1);
columnSine = 0;
columnOffset = 0;
columnScale = -1;  // appearance effect

//states
state = 0;  // 0 = default, 1 = TMM title, 2 = Author, 3 = Thank You
stateTo = 0;

//TitleLogo
logoBlueRate = 2*pi/340;
logoYellowRate = 2*pi/480;
logoColorOut = make_color_rgb(125, 237, 218);
logoColorO = make_color_rgb(247, 157, 61);
logoColorY = make_color_rgb(247, 194, 61);
logoColorA = make_color_rgb(123, 193, 243);
logoColorB = make_color_rgb(118, 151, 242);
logoColorDB = make_color_rgb(44, 62, 115); //gradient
logoColorR = make_color_rgb(168, 77, 52);  //gradient

//    DISPLAYED TEXT    \\

//Initialize arrays at their largest size
title[7, 1] = "";
levelNum[7] = 0;
levels[5, 7] = "";
makers[5, 7] = "";
makerIcon[4, 7] = "";

title[0, 0] = "Stage 1";
title[0, 1] = "Royalty-Free Safe Space";
title[1, 0] = "Boss 1";
title[1, 1] = scrGetRoomInfo(rChaozB, 0);
title[2, 0] = "Stage 2";
title[2, 1] = "Not Another NANG Clone";
title[3, 0] = "Boss 2";
title[3, 1] = scrGetRoomInfo(rGeezer01, 0);
title[4, 0] = "Stage 3";
title[4, 1] = "Knockoff Rush";
title[5, 0] = "Stage 4";
title[5, 1] = "Fractured Flashbacks";
title[6, 0] = "Final Boss";
title[6, 1] = "Mr. Scribble";
title[7, 0] = "Testers";
title[8, 0] = "Additional Thanks To...";

levelNum[0] = 8;
levelNum[1] = 6;
levelNum[2] = 8;
levelNum[3] = 5;
levelNum[4] = 3;
levelNum[5] = 4;
levelNum[6] = 10;  // 10 "The Elephant Crew" devs
levelNum[7] = 8;
levelNum[8] = 5;

//Level names
levels[0, 0] = scrGetRoomInfo(rStage01Abstr4ktNew, 0);
levels[0, 1] = scrGetRoomInfo(rStage01Dice, 0);
levels[0, 2] = scrGetRoomInfo(rStage01Kurath, 0);
levels[0, 3] = scrGetRoomInfo(rStage01Zilily, 0);
levels[0, 4] = scrGetRoomInfo(rStage01Purify, 0);
levels[0, 5] = scrGetRoomInfo(rStage01Onetwentyeight, 0);
levels[0, 6] = scrGetRoomInfo(rStage01Patrick, 0);
levels[0, 7] = scrGetRoomInfo(rStage01Ace, 0);

for (var i=0; i&lt;levelNum[1]; i++){
    levels[1, i] = scrGetAttackInfo(rChaozB, i, 0);
    makers[1, i] = scrGetAttackInfo(rChaozB, i, 1);
}

levels[2, 0] = scrGetRoomInfo(rStage02Shark1, 0);
levels[2, 1] = scrGetRoomInfo(rStage02Shark2, 0);
levels[2, 2] = scrGetRoomInfo(rStage02Erik, 0);
levels[2, 3] = scrGetRoomInfo(rStage02Klamy, 0);
levels[2, 4] = scrGetRoomInfo(rStage02Abstr4ktNew, 0);
levels[2, 5] = scrGetRoomInfo(rStage02Vovka, 0);
levels[2, 6] = scrGetRoomInfo(rStage02Telejump, 0);
levels[2, 7] = scrGetRoomInfo(rStage02Flappy, 0);

for (var i=0; i&lt;levelNum[3]; i++){
    levels[3, i] = scrGetAttackInfo(rGeezer01, i, 0);
    makers[3, i] = scrGetAttackInfo(rGeezer01, i, 1);
}
levels[4, 0] = scrGetRoomInfo(rStage03PvZ, 0);
levels[4, 1] = scrGetRoomInfo(rStage03Undertale, 0);
levels[4, 2] = scrGetRoomInfo(rStage03Touhou, 0);

levels[5, 0] = "";
levels[5, 1] = "";
levels[5, 2] = "";
levels[5, 3] = "";

for (var i=0; i&lt;levelNum[6]; i++){
    makers[6, i] = scrGetAttackInfo(rFinalBoss_1, i, 1);
    levels[6, i] = makers[6, i];
}

//Maker names
makers[0, 0] = "Abstr4kt";
makers[0, 1] = "DiceIWM";
makers[0, 2] = "kurath";
makers[0, 3] = "zilily";
makers[0, 4] = "kid-purify";
makers[0, 5] = "128-Up";
makers[0, 6] = "Patrick";
makers[0, 7] = "AceEmX2";


makers[2, 0] = "Shark3143";
makers[2, 1] = "Shark3143";
makers[2, 2] = "RandomErik";
makers[2, 3] = "Klamy";
makers[2, 4] = "Abstr4kt";
makers[2, 5] = "VovkaZX";
makers[2, 6] = "Thenewgeezer";
makers[2, 7] = "Zorgo";

makers[4, 0] = scrGetRoomInfo(rStage03PvZ, 1);
makers[4, 1] = scrGetRoomInfo(rStage03Undertale, 1);
makers[4, 2] = scrGetRoomInfo(rStage03Touhou, 1);

makers[5, 0] = "";
makers[5, 1] = "";
makers[5, 2] = "";
makers[5, 3] = "";

makers[6, 0] = "";

makers[7, 0] = "Zilyno";
makers[7, 1] = "Essisten";
makers[7, 2] = "MKey";
makers[7, 3] = "phgQED";
makers[7, 4] = "Mayuri Nanako";
makers[7, 5] = "K1M2W";
makers[7, 6] = "strelook21";
makers[7, 7] = "Bloomy";

makers[8, 0] = "The Elephant Crew";
makers[8, 1] = "Abstr4kt";
makers[8, 2] = "Patrick";
makers[8, 3] = "Zapmunk";
makers[8, 4] = "Kelvar";

levels[8, 0] = 'Making "I Wanna Maker"';
levels[8, 1] = "Unbeknowingly inspiring this game";
levels[8, 2] = "Helping me get approval for this project";
levels[8, 3] = "Helping me with two shaders#for the Knockoff Touhou section";
levels[8, 4] = "Finishing the final boss##Making this credits sequence##Wrapping up the game##(Apparently it wasn't as close to being finished as I thought...)";


//Icons info
icons[0, 0] = scrGetRoomInfo(rStage01Abstr4ktNew, 3);
icons[0, 1] = scrGetRoomInfo(rStage01Dice, 3);
icons[0, 2] = scrGetRoomInfo(rStage01Kurath, 3);
icons[0, 3] = scrGetRoomInfo(rStage01Zilily, 3);
icons[0, 4] = scrGetRoomInfo(rStage01Purify, 3);
icons[0, 5] = scrGetRoomInfo(rStage01Onetwentyeight, 3);
icons[0, 6] = scrGetRoomInfo(rStage01Patrick, 3);
icons[0, 7] = scrGetRoomInfo(rStage01Ace, 3);

icons[1, 0] = 5;
icons[1, 1] = 7;
icons[1, 2] = 8;
icons[1, 3] = 10;
icons[1, 4] = 11;
icons[1, 5] = 46;  // AceEmX wasn't in a practice mode screenshot before  :P

icons[2, 0] = scrGetRoomInfo(rStage02Shark1, 3);
icons[2, 1] = scrGetRoomInfo(rStage02Shark2, 3);
icons[2, 2] = scrGetRoomInfo(rStage02Erik, 3);
icons[2, 3] = scrGetRoomInfo(rStage02Klamy, 3);
icons[2, 4] = scrGetRoomInfo(rStage02Abstr4ktNew, 3);
icons[2, 5] = scrGetRoomInfo(rStage02Vovka, 3);
icons[2, 6] = scrGetRoomInfo(rStage02Telejump, 3);
icons[2, 7] = scrGetRoomInfo(rStage02Flappy, 3);

icons[3, 0] = 13;
icons[3, 1] = 14;
icons[3, 2] = 15;
icons[3, 3] = 17;
icons[3, 4] = 47;

icons[4, 0] = scrGetRoomInfo(rStage03PvZ, 3);
icons[4, 1] = scrGetRoomInfo(rStage03Undertale, 3);
icons[4, 2] = scrGetRoomInfo(rStage03Touhou, 3);

icons[5, 0] = scrGetRoomInfo(rStage04New_1, 3);
icons[5, 1] = scrGetRoomInfo(rStage04New_2, 3);
icons[5, 2] = scrGetRoomInfo(rStage04New_3, 3);
icons[5, 3] = scrGetRoomInfo(rStage04New_4, 3);

icons[6, 0] = scrGetRoomInfo(rFinalBoss_1, 3);
icons[6, 1] = sprFinalLarryFlipped;
icons[6, 2] = sprFinalKnightFallFlipped;
icons[6, 3] = sprFinalKirbyRollFlipped;
icons[6, 4] = sprFinalKadyCacao;
icons[6, 5] = sprFinalKurathChaser;
icons[6, 6] = sprFinalPatToaster;
icons[6, 7] = sprFinalYoyoMiku;
icons[6, 8] = sprFinalDribixWaveColored;
icons[6, 9] = sprFinalTralexBartenderColored;
icons[6, 10] = sprFinalSudnepMiku;

for (var i=0; i&lt;=4; i++){
    for (var j=0; j&lt;levelNum[i]; j++){
        makerIcon[i, j] = scrMakerToKidSubimg(makers[i, j]);
    }
}

listColCircle = make_color_rgb(114, 129, 164);
listColClick = make_color_rgb(63, 67, 117);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_other, ev_room_end);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _abstr4kt2Tileset = 11;
var _deltaTimeMult = clamp(delta_time/20000, 1, 4);

timerPrecise += 1*_deltaTimeMult;
timer = floor(timerPrev);
while (floor(timerPrecise) &gt; timer){
    timer ++;
    event_user(1);  // Time-based actions
}
timerPrev = timerPrecise;

// Sync music; Create identifier and timer; Track progress
if (timer &gt;= 0 &amp;&amp; timer &lt; 11780 &amp;&amp; !global.muteMusic &amp;&amp; global.musicLevel &gt; 0 &amp;&amp; global.volumeLevel &gt; 0){
    if (global.currentMusicID == global.BGMCredits &amp;&amp; audio_is_playing(global.currentMusic) &amp;&amp; abs(audio_sound_get_track_position(global.currentMusic) - (timer-1)/50) &gt; 0.12){
        audio_sound_set_track_position(global.currentMusic, (timer-1)/50);
    }
}

/*
if (global.debugMode &amp;&amp; global.debugNoDeath){
    if (mouse_wheel_up()){
        creditsScrollHeight -= 60;
    }
    if (mouse_wheel_down()){
        creditsScrollHeight += 60;
    }
}
*/

if (creditsScrollSpd != 0){
    creditsScrollHeight += creditsScrollSpd*_deltaTimeMult;
}
if (columnSine &gt; 0){
    columnSine = max(columnSine - pi/12*_deltaTimeMult, 0);
    columnOffset = -32*(1 - cos(columnSine))/2;
    reload = true; //reload surface to update the tile columns
}
if (tilesetDrawing == _abstr4kt2Tileset || tileState == 2){  // for the hue-shifting effect
    reload = true;
}

// Manage Effects

//Black fade in/out
if (timer &lt; 4000){
    if (fadeTimer &gt; 0){fadeTimer -= 1*_deltaTimeMult;}
}else{
    fadeTimerInit = 250;
    fadeTimer += 1*_deltaTimeMult;
    if (timer &gt;= 4395){
        var _inst = instance_create(0, 0, objScreenFade);
        _inst.color = c_black;
        _inst.fade = 1;
        _inst.fadeOut = 1/80;
        _inst.alpha = 1 + (8*_inst.fadeOut);
        
        _inst.persistent = true;
        _inst.roomTo = rTMM_ClearLobby;
        room_goto(rTMM_ClearLobby);
    }
}

// Logo + Author fading
if (state &lt; stateTo){
    if (stateTo == 1 &amp;&amp; state &lt; 1){
        state = min(state + _deltaTimeMult/115, 1);
    }
    if (stateTo == 2 &amp;&amp; state &lt; 2){
        state = min(state + _deltaTimeMult/60, 2);
    }
}

// Tile shuffling
if (tileState == 1){
    if (tileStateCounter &lt; 1){
        tileStateCounter += _deltaTimeMult/60;
        reload = true; //reload surface to update the tile alpha
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Background
switch(tilesetDrawing){
    case 2: //Dice
        draw_background(bkMakerSky, -(global.count mod 500), 0);
        draw_background(bkMakerSky, -(global.count mod 500) + 500, 0);
        draw_background(bkMakerSky, -(global.count mod 500) + 1000, 0);
        draw_background(bkMakerSky, -(global.count mod 500), 500);
        draw_background(bkMakerSky, -(global.count mod 500) + 500, 500);
        draw_background(bkMakerSky, -(global.count mod 500) + 1000, 500);
        break;
    case 4: //zilily
        draw_set_color(zililyCol);
        draw_rectangle(0, 0, 800, 608, false);
        draw_set_color(c_white);
        draw_sprite_ext(sprS1ZililyBK, global.count/2, 0, 0, 2, 2, 0, c_white, 1);
        break;
    case 5: ///128-Up
        draw_background_tiled(bkS1Onetwentyeight, 0, 0);
        break;
    case 6: //Patrick
        if (global.hueshiftEnabled){
            shader_set(shdHueShift);
            shader_set_uniform_f(global.hueshiftHandle, 1.745);
            draw_background_tiled(bkS2Abstr4ktNew, -((0.425*global.count) mod 256), 0);
            shader_reset();
        }else{
            draw_set_color(c_white);
            draw_rectangle(0-0.5, 0-0.5, 800-0.5, 608-0.5, false);
            draw_background_tiled_ext(bkS2Abstr4ktShaderFailsafe, -((0.425*global.count) mod 256), 0, 1, 1, patrickFailsafeCol, 1);
        }
        break;
    case 7: //Chaoz Airflow
        draw_background_tiled(bkChaoz, 0, 0);
        break;
    case 8: //Shark 1/2
        draw_background_tiled(bkCreditsShark, 0, 0);
        break;
    case 10: //Klamy Spiky Situation
        draw_background_tiled(bkS2Klamy, 0, 0);
        break;
    case 11: //Abstr4kt 2
        var _resetShader = false;
        if (global.hueshiftEnabled){
            shader_set(shdHueShift);
            _resetShader = true;
            shader_set_uniform_f(global.hueshiftHandle, 2*pi * global.count/400);
            draw_background_tiled(bkS2Abstr4ktNew, -((0.425*global.count) mod 256), 0);
        }else{
            draw_set_color(c_white);
            draw_rectangle(0-0.5, 0-0.5, 800-0.5, 608-0.5, false);
            draw_background_tiled_ext(bkS2Abstr4ktShaderFailsafe, -((0.425*global.count) mod 256), 0, 1, 1, make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225), 1);
        }
        
        if (_resetShader){
            shader_reset();
            _resetShader = false;
        }
        break;
    case 12: //Vovka
        draw_background_tiled(bkS2Vovka, 0, 0);
        break;
    case 13: //Telejump
    case 14: //Geezer
        draw_set_color(c_black);
        draw_rectangle(0, 0, 800, 608, false);
        draw_set_color(c_white);
        break;
    case 15: //Hitchcock
        draw_set_color(hitchcockCol);
        draw_rectangle(0, 0, 800, 608, false);
        draw_set_color(c_white);
        break;
    case 16: //UNUSED - Stage Rush
        draw_background_tiled(bkS3Hub, 0, 0);
        break;
    case 17: //Final Boss
        if (global.finalBKEnabled){
            shader_set(shdFinalBossBK);
            shader_set_uniform_f(global.finalbossHandle, global.countPersistent * 0.0025);
            shader_set_uniform_f(global.finalbossHandle2, 800, 608);
            texture_set_repeat(true);
            draw_rectangle(0, 0, 800, 608, false);
            texture_set_repeat(false);
            shader_reset();
        }else{
            scrDrawTiledArea(bkFinalScribbleFailsafe, -((floor(0.25*global.countPersistent) - (11 / max(view_wview/800, 0.01))) mod 512), ((floor(0.875*global.countPersistent) - (12 / max(view_hview/608, 0.01))) mod 512), view_xview, view_yview, view_xview + view_wview, view_yview + view_hview);
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///TMM Logo
// Set title values
var _blueRate = 2*pi/340;
var _yellowRate = 2*pi/480;
var _blueCounter = (timerPrecise-3880)*_blueRate;
var _yellowCounter = (timerPrecise-3880)*_yellowRate;

// Generate title image
var _surfY = 0, _surfAlpha = 1;
if (stateTo == 1 || stateTo == 2){
    scrTMMGenTitle(1, global.countPersistent, 210, 172, 6 + 2.5*sin(_blueCounter), "THE", 458, 398, 3 + 1.75*sin(_blueCounter + 3*pi/5), "MEDLEY", 379, 291, 2.5*sin(_yellowCounter + 3*pi/5), "M  KER");
    _surfY = -2*creditsScrollHeight;
    _surfAlpha = min(state, 1);
}else if (stateTo == 3){
    scrTMMGenTitle(3, global.countPersistent, 196, 304, 4.5*sin(-_blueCounter), "YOU", 548, 304, 4.5*sin(-_blueCounter + pi*4/3), "FOR", 292, 132, 6 + 2.5*sin(_yellowCounter), "TH  NK", 456, 480, 3 + 1.75*sin(_yellowCounter + 3*pi/5), "PL  YING");
    _surfY = 0;
    _surfAlpha = 1;
}

//Draw text to final surface (needed for the initial fade in)
if (!surface_exists(global.sharedSurf3)){
    global.sharedSurf3 = surface_create(800, 608);
}
if (surface_exists(global.sharedSurf3)){
    surface_set_target(global.sharedSurf3);
    draw_clear_alpha(c_black, 0);
    
    scrTMMDrawTitle(400, 304, 0.75, 0.75);
    
    surface_reset_target();
    
    if (surface_exists(global.sharedSurf3)){
        draw_surface_ext(global.sharedSurf3, 0, _surfY, 1, 1, 0, c_white, _surfAlpha);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="14">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///  Create/Refresh tile surface

// variables for special cases
var _sharkIndex = 8;  // shark has 2 layers of the beam tiles
var _abstr4kt2Index = 11;  // hueshifting
var _resetShader = false;
var _abstr4kt2FailsafeCol = c_white;
var _tileset = tilesetDrawing;

if (!surface_exists(tileSurf)){
    tileSurf = surface_create(800, 608);
}
if (surface_exists(tileSurf)){
    surface_set_target(tileSurf);
    draw_clear_alpha(c_black, 0);
    
    if (tileState == 0 || (tileState == 1 &amp;&amp; tileStateCounter &lt; 1)){
        if (tilesetDrawing == _abstr4kt2Index){
            if (global.hueshiftEnabled){
                shader_set(shdHueShift);
                shader_set_uniform_f(global.hueshiftHandle, global.count*2*pi/400);
                _resetShader = true;
            }else{
                scrCreditsDrawMainArena(8.1);
                image_blend = make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225);
                draw_set_color_write_enable(1, 1, 1, 0);
                scrCreditsDrawMainArena(11.1);
                draw_set_color_write_enable(1, 1, 1, 1);
                _tileset = noone;
            }
        }
        
        if (_tileset != noone){
            scrCreditsDrawMainArena(_tileset);
        }
        
        //S2 Abstr4kt clean-up
        if (_resetShader){
            shader_reset();
            _resetShader = false;
        }
        
        event_user(3);  // draw spikes
        image_blend = c_white;
    }
    
    var _state2Column = tileColumnFarthest;
    if (columnScale &lt; 1){
        _state2Column = -1;
    }else{
        if (columnSine != 0){_state2Column -= 1;}  // account for transition effect
    }
    if (tileState == 1 || (tileState == 2 &amp;&amp; _state2Column &lt; 24)){
        var _usingSurface = false;
        if (tileState == 1 &amp;&amp; tileStateCounter &lt; 1){
            if (!surface_exists(global.sharedSurf)){
                global.sharedSurf = surface_create(800, 608);
            }
            
            if (surface_exists(global.sharedSurf)){
                surface_set_target(global.sharedSurf);
                draw_clear_alpha(c_black, 0);
                _usingSurface = true;
            }
        }
        
        //outer border    (   Shark's tileset makes this harder than it would be otherwise... :P   )
        for (var i=(_state2Column+1); i&lt;25; i++){
            if (tilesH[0, i] != _sharkIndex){
                scrTitleDrawTiles(tilesH[0, i], 4, 32*i, 0);
            }else{
                scrTitleDrawTiles(tilesH[0, i], 7, 32*i, 0);
            }
            if (tilesH[3, i] != _sharkIndex){
                scrTitleDrawTiles(tilesH[3, i], 4, 32*i, 576);
            }else{
                scrTitleDrawTiles(tilesH[3, i], 1, 32*i, 576);
            }
        }
        if (_state2Column &lt; 0){
            for (var j=0; j&lt;15; j++){
                if (tilesV[j, 0] != _sharkIndex){
                    scrTitleDrawTiles(tilesV[j, 0], 4, 0, 32*(j+2));
                }else{
                    scrTitleDrawTiles(tilesV[j, 0], 3, 0, 32*(j+2));
                }
            }
        }
        if (_state2Column &lt; 24){   //gauranteed
            for (var j=0; j&lt;15; j++){
                if (tilesV[j, 3] != _sharkIndex){
                    scrTitleDrawTiles(tilesV[j, 3], 4, 768, 32*(j+2));
                }else{
                    scrTitleDrawTiles(tilesV[j, 3], 3, 768, 32*(j+2));
                }
            }
        }
        
        //inner border
        for (var i=(_state2Column+1); i&lt;23; i++){
            scrTitleDrawTiles(tilesH[1, i], 7, 32*i, 32);
            scrTitleDrawTiles(tilesH[2, i], 1, 32*i, 544);
        }
        
        if (_state2Column &lt; 1){
            for (var j=0; j&lt;15; j++){
                scrTitleDrawTiles(tilesV[j, 2], 5,  32, 32*(j+2));
            }
            //corners
            scrTitleDrawTiles(tilesH[1, 1], 10, 32, 32);
            scrTitleDrawTiles(tilesH[2, 1], 12, 32, 544);
        }
        if (_state2Column &lt; 23){
            for (var j=0; j&lt;15; j++){
                scrTitleDrawTiles(tilesV[j, 1], 3, 736, 32*(j+2));
            }
            //corners
            scrTitleDrawTiles(tilesH[1, 23], 11, 736, 32);
            scrTitleDrawTiles(tilesH[2, 23], 13, 736, 544);
        }
        
        if (_usingSurface){
            surface_reset_target();  //resets from global.sharedSurf  to  tileSurf
            
            draw_set_colour_write_enable(true, true, true, false);  //surface alpha yippee!
            draw_surface_ext(global.sharedSurf, 0, 0, 1, 1, 0, c_white, tileStateCounter);
            draw_set_colour_write_enable(true, true, true, true);   //reset to default
        }
    }
    
    event_user(3); // Draw Spikes (on tileSurf)
    
    if ((tileState == 1 || tileState == 2) &amp;&amp; columnScale &gt; 0 &amp;&amp; tileColumnFarthest &gt;= 0){
        for (var i=0; i&lt;=min(tileColumnFarthest, (columnNum-1)); i++){  // tileColumnFarthest represents the farthest *index*
            if (tileColumns[i] != -1){
                scrCreditsDrawTileColumn(tileColumns[i], i, columnOffset, columnScale);
            }
        }
    }
    
    surface_reset_target();
    reload = false; //reloaded successfully
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Spikes
var _vertLeft = 112;
var _vertRight = 688;
var _horTop = 112;
var _horBottom = 496;

var _abstr4kt2Tileset = 11;
var _resetShader = false;

if (tileState == 0 || (tileState == 1 &amp;&amp; tileStateCounter &lt; 1)){
    var _spikeInd = scrCreditsStageSpikeIndex(tilesetDrawing);
    var _spikeBlend = c_white;
    var _spikeAlpha = 1;
    var _resetShader = false;
    var _resetChannels = false;
    
    // S2 Abstr4kt behavior
    if (tilesetDrawing == _abstr4kt2Tileset){
        if (!global.hueshiftEnabled){
            _spikeInd = 0;
            _spikeBlend = make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225);
            _spikeAlpha = 0.3;
            
            for (var i=_vertLeft; i&lt;=_vertRight; i+=32){
                draw_sprite_ext(sprMakerSpike, _spikeInd, i + drawXOff, 528 + drawYOff, 1, 1, 0, c_white, 1);   //bottom
                draw_sprite_ext(sprMakerSpike, _spikeInd, i + drawXOff,  80 + drawYOff, 1, -1, 0, c_white, 1);   //top
            }
            for (var j=_horTop; j&lt;=_horBottom; j+=32){
                draw_sprite_ext(sprMakerSpike, _spikeInd,  80 + drawXOff, j + drawYOff, 1, 1, 270, c_white, 1); //left
                draw_sprite_ext(sprMakerSpike, _spikeInd, 720 + drawXOff, j + drawYOff, 1, -1, 270, c_white, 1);  //right
            }
            
            draw_set_colour_write_enable(1, 1, 1, 0);
            _resetChannels = true;
        }else{
            shader_set(shdHueShift);
            shader_set_uniform_f(global.hueshiftHandle, 2*pi * global.count/400);
            _resetShader = true;
        }
    }
    
    // Draw spikes
    for (var i=_vertLeft; i&lt;=_vertRight; i+=32){
        draw_sprite_ext(sprMakerSpike, _spikeInd, i + drawXOff, 528 + drawYOff, 1, 1, 0, _spikeBlend, _spikeAlpha);   //bottom
        draw_sprite_ext(sprMakerSpike, _spikeInd, i + drawXOff,  80 + drawYOff, 1, -1, 0, _spikeBlend, _spikeAlpha);   //top
    }
    for (var j=_horTop; j&lt;=_horBottom; j+=32){
        draw_sprite_ext(sprMakerSpike, _spikeInd,  80 + drawXOff, j + drawYOff, 1, 1, 270, _spikeBlend, _spikeAlpha); //left
        draw_sprite_ext(sprMakerSpike, _spikeInd, 720 + drawXOff, j + drawYOff, 1, -1, 270, _spikeBlend, _spikeAlpha);  //right
    }
                
    // S2 Abstr4kt cleanup
    if (_resetChannels){
        draw_set_colour_write_enable(1, 1, 1, 1);
    }
    if (_resetShader){
        shader_reset();
        _resetShader = false;
    }
}

var _state2Column = tileColumnFarthest;
if (columnScale &lt; 1){
    _state2Column = -1;
}else{
    if (columnSine != 0){_state2Column -= 1;}  // account for transition effect
}
if (tileState == 1 || (tileState == 2 &amp;&amp; _state2Column &lt; 23)){
    //no abstr4kt shader here because it would be way too performance-intensive
    var _alpha = 1;
    if (tileState == 1 &amp;&amp; tileStateCounter &lt; 1){
        _alpha = tileStateCounter;
    }
    for (var i = max(_state2Column-2, 0); i&lt;=18; i+=1){
        draw_sprite_ext(sprMakerSpike, spikesH[0, i], (_vertLeft + i*32),    (_horTop-32), 1, -1, 0, c_white, _alpha);  //top
        draw_sprite_ext(sprMakerSpike, spikesH[1, i], (_vertLeft + i*32), (_horBottom+32), 1, 1, 0, c_white, _alpha);   //bottom
    }
    if (_state2Column &lt; ((_vertLeft div 32)-1)){
        for (var j=0; j&lt;=12; j+=1){
            draw_sprite_ext(sprMakerSpike, spikesV[0, j],  (_vertLeft-32), (_horTop + j*32), 1, 1, 270, c_white, _alpha);    //left
        }
    }
    if (_state2Column &lt; ((_vertRight div 32)+1)){
        for (var j=0; j&lt;=12; j+=1){
            draw_sprite_ext(sprMakerSpike, spikesV[1, j], (_vertRight+32), (_horTop + j*32), 1, -1, 270, c_white, _alpha);     //right
        }
    }
}

// tileState 2 draws spikes when it draws columns of tiles
/*if (tileState == 2 &amp;&amp; tileColumnFarthest &gt;= 2){
    var _spikeInd;
    for (var i=3; i&lt;=min(tileColumnFarthest, 21); i+=1){
        _spikeInd = scrCreditsStageSpikeIndex(tileColumns[i]);
        if (tilesetDrawing == _abstr4kt2Tileset &amp;&amp; !global.hueshiftEnabled){
            var _col = make_color_hsv(255 * (1 - (global.count mod 400)/400), 225, 225);
            for (var i=_vertLeft; i&lt;=_vertRight; i+=32){
                draw_sprite_ext(sprMakerSpike, 0, i, 528, 1, 1, 0, _col, 1);   //bottom
                draw_sprite_ext(sprMakerSpike, 0, i, 80, 1, -1, 0, _col, 1);   //top
            }
            for (var j=_horTop; j&lt;=_horBottom; j+=32){
                draw_sprite_ext(sprMakerSpike, 0,  80, j, 1, -1, 90, _col, 1); //left
                draw_sprite_ext(sprMakerSpike, 0, 720, j, 1, 1, 90, _col, 1);  //right
            }
        }else{
            if (tileColumns[i] == _abstr4kt2Tileset &amp;&amp; global.hueshiftEnabled){
                _resetShader = true;
                shader_set(shdHueShift);
                shader_set_uniform_f(global.hueshiftHandle, global.count*pi/200);
            }
            draw_sprite_ext(sprMakerSpike, _spikeInd, (i*32 + 16), 528, 1, 1, 0, c_white, 1);   //bottom
            draw_sprite_ext(sprMakerSpike, _spikeInd, (i*32 + 16), 80, 1, -1, 0, c_white, 1);   //top
            
            if (_resetShader){
                shader_reset();
                _resetShader = false;
            }
        }
    }
    _spikeInd = scrCreditsStageSpikeIndex(tileColumns[2]);
    if (tileColumns[2] == _abstr4kt2Tileset &amp;&amp; global.hueshiftEnabled){
        _resetShader = true;
        shader_set(shdHueShift);
        shader_set_uniform_f(global.hueshiftHandle, global.count*pi/200);
    }
    for (var j=3; j&lt;=15; j+=1){  //left
        draw_sprite_ext(sprMakerSpike, _spikeInd,  80, (32*j + 16), 1, -1, 90, c_white, 1);
    }
    if (_resetShader){
        shader_reset();
        _resetShader = false;
    }
    
    
    if (tileColumnFarthest &gt;= 22){
        _spikeInd = scrCreditsStageSpikeIndex(tileColumns[22]);
        if (tileColumns[22] == _abstr4kt2Tileset &amp;&amp; global.hueshiftEnabled){
            _resetShader = true;
            shader_set(shdHueShift);
            shader_set_uniform_f(global.hueshiftHandle, global.count*pi/200);
        }
        for (var j=3; j&lt;=15; j+=1){  //right
            draw_sprite_ext(sprMakerSpike, _spikeInd, 720, (32*j + 16), 1, 1, 90, c_white, 1);
        }
        if (_resetShader){
            shader_reset();
            _resetShader = false;
        }
    }
}*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update tiles (tileState 1 and 2)
if (tileState == 1){  //scrambling
    //var _abst4rkt2Index = 11
    for (var j=3; j&gt;=0; j--){
        for (var i=24; i&gt;=0; i--){
            tilesH[j, i] = choose(4, 5, 6, 7, 8, 10, 12, 13, 15);  //top and bottom (+ corners)
        }
    }
    for (var i=3; i&gt;=0; i--){
        for (var j=14; j&gt;=0; j--){
            tilesV[j, i] = choose(4, 5, 6, 7, 8, 10, 12, 13, 15);  // left and right
        }
    }
    for (var i=18; i&gt;=0; i--){
        spikesH[1, i] = scrCreditsStageSpikeIndex( choose(4, 5, 6, 7, 8, 10, 12, 13, 15) );     //bottom
        spikesH[0, i] = scrCreditsStageSpikeIndex( choose(4, 5, 6, 7, 8, 10, 12, 13, 15) );     //top
    }
    for (var i=12; i&gt;=0; i--){
        spikesV[1, i] = scrCreditsStageSpikeIndex( choose(4, 5, 6, 7, 8, 10, 12, 13, 15) );     //right
        spikesV[0, i] = scrCreditsStageSpikeIndex( choose(4, 5, 6, 7, 8, 10, 12, 13, 15) );     //left
    }
    
    /*
    //tileState1_Background = choose(4, 5, 6, 7, 8, 10, 12, 15);  // &lt;- 8 options
    var _options = 8;
    var _index = irandom_range(0, (_options-1)), _roomVal = 0;
    
    while (_index == tilesetPrev[0] || _index == tilesetPrev[1] || _index == tilesetPrev[2]){
        _index = (_index + 1) mod _options;
    }
    
    //manage previous tileset array (holds previous *index*, not *room*)
    tilesetPrev[2] = tilesetPrev[1];
    tilesetPrev[1] = tilesetPrev[0];
    tilesetPrev[0] = _index;
    
    /*  // honestly concerned this could negatively interact with some types of epilepsy
    //convert indexes into rooms values using the previously outlined method
    if (_index &lt;= 4){
        _roomVal = _index+4;
    }else if (_index == 5){
        _roomVal = 10;
    }else if (_index == 6){
        _roomVal = 12;
    }else if (_index == 7){
        _roomVal = 15;
    }
    tileState1_Background = _roomVal;
    */
}
if (tileState == 2){  //column movement
    event_user(0);
}

reload = true;  //flag the surface to be updated
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Time-based actions
switch (timer){
    //  [TILESET CYCLING]
    /*
    case     1:
    case    26:
    case    52:
    case   138:
    case   164:
    case   190:
    case   277:
    case   303:
    case   329:
    case   415:
    case   442:
    case   468:
    case   554:
    case   580:
    case   606:
    case   693:
    case   719:
    case   745:
    case   831:
    case   857:
    case   884:
    case   970:
    case   996:
    case  1022:*/
    
    // *Credits begin scrolling*
    
    //  [TILESET CYCLING]
    case 556:
    case 582:
    case 608:
    case 694:
    case 720:
    case 746:
    case 833:
    case 859:
    case 885:
    case 972:
    case 998:
    case 1024:
    case 1110:
    case 1136:
    case 1162:
    case 1275:
    case 1301:
    case 1249:
    case 1388:
    case 1414:
    case 1440:
        event_user(0);
    break;
    case 276:
        stateTo = 1;
    break;
    case 415:
        stateTo = 2;
    break;
    case 520:
        creditsScrollSpd = 0.5;
    break;
    case 555:
        creditsScrollSpd = 2.0667;
    break;
    case 1525:
        tileState = 1; //scramble tiles
        tileStateCounter = 0;
        columnScale = -1;
    break;
    case 1567:  // make tile columns appear
        columnScale = 0;
        
        // make tile column array start "empty"
        for (var i=(columnNum-1); i&gt;=0; i-=1;){
            tileColumns[i] = -1;
        }
        tileColumnFarthest = (columnNum-1);
        // fill column array
        for (var i=(2 + 24); i&gt;=2; i-=3;){
            event_user(0);  // sets tileColumns[0]
            tileColumns[i] = tileColumns[0];
        }
        tileColumns[0] = -1;  // User Event 2 set this index, but we need tileColumns[0] to start at -1
    break;
    case 1663:  // begin column shifting
        tileState = 2;
        columnScale = 1;
    break;
    case 3872:  // to 3880
        var _len = 8;  // of fade in
        var _inst;
        _inst = instance_create(0, 0, objScreenFade);
        _inst.color = c_white;
        _inst.fadeIn = 1/_len;
        _inst.alarm[0] = _len;
        _inst.fadeOut = 0.0175;
    break;
    case 3880:
        stateTo = 3;
        state = 3;
        creditsScrollSpd = 0;
        creditsScrollHeight = 0;
    break;
    
    /*case 4295:
        creditsScrollSpd = 0
    case 4304.5:
    case 4321.5:
    case 4339:
    case 4356:
    case 4373.5:
    case 4390.5:
    case 4408:
        creditsScrollHeight += 80;
    break;
    case 4421:
    case 4425:
    case 4430:
        creditsScrollHeight += 16;
    break;
    case 4432:
        creditsScrollSpd = 1.5;
    break;*/
}

// State 2 timings
var _state2AppearStart = 1567;
var _state2AppearEnd = 1649;
var _state2StartTime = 1663;
var _state2SwitchInterval = 18;

// column "expanding"
if (tileState == 1){
    columnScale = clamp(max(floor(timer) - _state2AppearStart, 0)/(_state2AppearEnd - _state2AppearStart), 0, 1);
    reload = true;
}

//scramble tiles
if (tileState == 1 &amp;&amp; (floor(timer) mod 6) == 0){
    event_user(2);
}else if (tileState == 2 &amp;&amp; (floor(timer-_state2StartTime) mod _state2SwitchInterval) == 0 &amp;&amp; timer &lt; 3872){
    //shift tiles 1 column right
    for (var i=(columnNum-1); i&gt;=1; i--;){
        tileColumns[i] = tileColumns[i-1];
    }
    
    if (floor(timer-_state2StartTime) mod (3*_state2SwitchInterval)  == 0){
        event_user(2);  // generate new column index
    }else{
        tileColumns[0] = -1;  // columns have already shifted one over
    }
    
    //update number of columns, if needed
    if (tileColumnFarthest &lt; (columnNum-1)){
        tileColumnFarthest += 1;  // refers to index in array
    }
    columnSine = pi;
    reload = true;  // flag the surface to be updated
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Choose new tileset
/*
    &gt; Room 0 (Intro) is the same as Room 3 (Dice)
    &gt; S1 Abstr4kt two tilesets do not work with the sequence's design, and both are present in other rooms, so it will be excluded
    &gt; rooms  7 and 9  have the same tileset and nearly identical backgrounds, so we'll Exclude 9
    &gt; room 13 is solid white-on-black, which is uninteresting, and the background contrasts poorly with the credits text
    &gt; room 14 (Geezer) barely has spikes, so we'll exclude 14 as well
Therefore, the range is  [2, (sections-1)] excluding  3, 9, 13, and 14    [2, 4-8, 10-12, 15]
We can represent these tileset with the range [0, 9] by...
    &gt; changing  0    to    2
    &gt; changing  1 -&gt; 5     to     4 -&gt; 8
    &gt; changing  6 -&gt; 8   to   10 -&gt; 12
    &gt; changing  9    to    15
*/

var _index = irandom_range(0, 9);
var _prevCheck = false;
var _failsafe = 0;
while (_failsafe &lt; 10){
    _prevCheck = true;
    for (var i=0; i&lt;tilesetPrevTracking; i++){
        if (_index == tilesetPrev[i]){
            _prevCheck = false;
            _index = (_index + 1) mod 10;
            //break;  // we'll continue through the loop. If any of the later previous indexes matches this one, it will still be invalid
        }
    }
    if (_prevCheck){break;}
    _failsafe ++;
}
if (_failsafe &gt;= 10){
    show_debug_message("FAILSAFE triggered when trying to choose next tileset!!  (stopped on _index = " + string(_index) + ")");
}

//manage previous tileset array (holds previous *index*, not *room*)
for (var i = (tilesetPrevTracking-1); i &gt;= 1; i--){
    tilesetPrev[i] = tilesetPrev[i-1];
}
tilesetPrev[0] = _index;

//convert indexes into rooms values using the previously outlined method
var _roomVal = 0;
if (_index == 0){
    _roomVal = 2;
}else if (_index &gt;= 1 &amp;&amp; _index &lt;= 5){
    _roomVal =  4  +  (_index - 1);
}else if (_index &gt;= 6 &amp;&amp; _index &lt;= 8){
    _roomVal = 10  +  (_index - 6);
}else if (_index == 9){
    _roomVal = 15;
}else{
    show_debug_message("ERROR: Unable to convert index " + string(_index) + " to a tileset");
}

if (tileState == 0){
    tilesetDrawing = _roomVal;
}else{
    tileColumns[0] = _roomVal;
}

/*Faster method
var _index = choose(4, 5, 6, 7, 8, 10, 11, 12, 13, 15);

while (_index == tilesetPrev[0] || _index == tilesetPrev[1] || _index == tilesetPrev[2]){
    _index = (_index + 1) mod sections;
}
tilesetDrawing = _index;

//manage previous tileset array (holds previous *index*, not *room*)
tilesetPrev[2] = tilesetPrev[1];
tilesetPrev[1] = tilesetPrev[0];
tilesetPrev[0] = _index;*/

reload = true; //reload surface to update the tiles
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>surface_free(tileSurf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (objWorld){
    musicToPlay = global.BGMCredits;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="72">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Background
if (!(tileState == 2 &amp;&amp; columnScale &gt;= 1 &amp;&amp; tileColumnFarthest &gt;= 23)){
    event_user(6);
}
if ((tileState == 1 || tileState == 2) &amp;&amp; columnScale &gt; 0){
    var _width = 96, _scaleOff = 0;
    if (columnScale &lt; 1){
        _width = columnScale*96;
        _scaleOff = 48 * (1-columnScale);
    }
    if (tileColumnFarthest &gt;= 2){
        for (var i=2; i&lt;=min(tileColumnFarthest, 25); i++){
            if (tileColumns[i] != -1){
                scrCreditsDrawBKColumn( tileColumns[i],  32*(i-2) + columnOffset + _scaleOff,  _width );
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//     [CREDITS]
if (creditsScrollHeight &lt; 512 || state == 3){ //TMM Logo
    if (state &gt; 0){
        event_user(5);
    }
    if (state &gt; 1 &amp;&amp; state &lt;= 2){
        draw_sprite_ext(sprCreditsCreator, 0, 512, 440 - 2*creditsScrollHeight, 0.75, 0.75, 9 + 3*sin((timer + 6) * pi/144), c_white, min(state-1, 1));
    }
}
scrCreditsDraw();

//     [BORDER]
if (tilesetDrawing != 17){
    if (!surface_exists(tileSurf) || reload){
        event_user(4);  // Create/Refresh tile surface
    }
    if (surface_exists(tileSurf)){
        draw_surface(tileSurf, 0, 0);
    }
}else{ //final boss tiles are animated (and not used in tileState 1 or 2)
    //outer border
    for (var i=0; i&lt;25; i++){
        scrTitleDrawTiles(tilesetDrawing, 4, 32*i, 0);
        scrTitleDrawTiles(tilesetDrawing, 4, 32*i, 576);
    }
    for (var j=0; j&lt;19; j++){
        scrTitleDrawTiles(tilesetDrawing, 4, 0, 32*j);
        scrTitleDrawTiles(tilesetDrawing, 4, 768, 32*j);
    }
    
    //inner border
    for (var i=2; i&lt;23; i++){
        scrTitleDrawTiles(tilesetDrawing, 7, 32*i, 32);
        scrTitleDrawTiles(tilesetDrawing, 1, 32*i, 544);
    }
    for (var j=2; j&lt;17; j++){
        scrTitleDrawTiles(tilesetDrawing, 3, 736, 32*j);
        scrTitleDrawTiles(tilesetDrawing, 5,  32, 32*j);
    }
    
    //corners
    scrTitleDrawTiles(tilesetDrawing, 10, 32, 32);
    scrTitleDrawTiles(tilesetDrawing, 11, 736, 32);
    scrTitleDrawTiles(tilesetDrawing, 12, 32, 544);
    scrTitleDrawTiles(tilesetDrawing, 13, 736, 544);
    
    var _beamIndex = abs(2 - ((global.count*6/50) + 2) mod 4);
    //top
    draw_sprite(sprFinalTiles, 6 + _beamIndex, 64 + 16, 32 + 16);
    draw_sprite(sprFinalTiles, 12 + _beamIndex, 704 + 16, 32 + 16);
    //bottom
    draw_sprite(sprFinalTiles, 6 + _beamIndex, 64 + 16, 544 + 16);
    draw_sprite(sprFinalTiles, 12 + _beamIndex, 704 + 16, 544 + 16);
    //left
    draw_sprite(sprFinalTiles, 15 + _beamIndex, 32 + 16, 64 + 16);
    draw_sprite(sprFinalTiles, 21 + _beamIndex, 32 + 16, 512 + 16);
    //right
    draw_sprite(sprFinalTiles, 15 + _beamIndex, 736 + 16, 64 + 16);
    draw_sprite(sprFinalTiles, 21 + _beamIndex, 736 + 16, 512 + 16);
    
    event_user(3);  // draw spikes  (not to tileSurf)
}

if (fadeTimer &gt; 0 &amp;&amp; fadeTimerInit &gt; 0){
    draw_set_alpha(fadeTimer/fadeTimerInit);
    draw_set_color(c_black);
    draw_rectangle(0, 0, 800, 608, false);
    draw_set_color(c_white);
    draw_set_alpha(1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
