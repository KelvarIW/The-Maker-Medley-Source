<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprDotkidOutlined</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scrLoadRecord();

// row numbering (order should match display order (for showAll behavior); no duplicates)
beelzRow = 0;
//beelzRowBuffed = 1;
chaozRow = 1;
//chaozRowBuffed = 3;
geezerRow = 2;
pvzRow = 3; undertaleRow = 4; touhouRow = 5;
stage4Row = 6;
scribbleRow = 7;
maxRows = (scribbleRow+1);

// possible labels
bossLabel[scribbleRow] = "Mr. Scribble";
bossLabel[beelzRow] = "Fly of Beelzebub Lowest Hits";
//bossLabel[beelzRowBuffed] = "                    [Buffed]";
bossLabel[chaozRow] = "Chaoz Airflow Lowest Hits";
//bossLabel[chaozRowBuffed] = "                 [Buffed]";
bossLabel[geezerRow] = "Obligatory Geezer";
bossLabel[pvzRow] = "Plants vs. Zombies Fastest Time";
bossLabel[undertaleRow] = "Undertale Lowest Hits";
bossLabel[touhouRow] = "Touhou Lowest Hits";
bossLabel[stage4Row] = "Fractured Flashbacks";

// values to check
bossValue[scribbleRow] = global.scribbleBeaten;
bossValue[beelzRow] = global.beelzHitLowest;
//bossValue[beelzRowBuffed] = global.beelzHardHitLowest;
bossValue[chaozRow] = global.chaozHitLowest;
//bossValue[chaozRowBuffed] = global.chaozHardHitLowest;
bossValue[geezerRow] = global.geezerBeaten;
bossValue[pvzRow] = global.pvzFastest;
bossValue[undertaleRow] = global.undertaleHitLowest;
bossValue[touhouRow] = global.touhouHitLowest;
bossValue[stage4Row] = (max(global.farthestRoom, global.farthestRoomEver) &gt; scrGetRoomNum(rStage04New_4));

// initialize these arrays; represent what rows actually will be drawn
for (var i=maxRows-1; i&gt;=0; i--){
    rowLabel[i] = "";
    rowValue[i] = -1;
    rowIndex[i] = 0;  // uses "row numbering" variables; may not match position in list of rows
}

// get number of rows of text to show
// at first, bosses that haven't been beaten will not be shown
showAll = (room == rTMM_ClearLobby || global.gameClearedEver);  // show all boss rows, replacing missing values with a default message
textRows = 0;
if (showAll){
    textRows = maxRows;
    for (var i=maxRows-1; i&gt;=0; i--){
        // this is why the order matters
        rowIndex[i] = i;
        rowLabel[rowIndex[i]] = bossLabel[rowIndex[i]];
        rowValue[rowIndex[i]] = bossValue[rowIndex[i]];
    }
}else{
    if (bossValue[beelzRow] &gt;= 0){
        rowLabel[textRows] = bossLabel[beelzRow];
        rowIndex[textRows] = beelzRow;
        rowValue[textRows] = bossValue[beelzRow];
        textRows ++;
        /*// Buffed
        if (bossValue[beelzRowBuffed] &gt;= 0){
            rowLabel[textRows] = bossLabel[beelzRowBuffed];
            rowIndex[textRows] = beelzRowBuffed;
            rowValue[textRows] = bossValue[beelzRowBuffed];
            textRows ++;
        }*/
    }
    if (bossValue[chaozRow] &gt;= 0){
        rowLabel[textRows] = bossLabel[chaozRow];
        rowIndex[textRows] = chaozRow;
        rowValue[textRows] = bossValue[chaozRow];
        textRows ++;
        /*// Buffed
        if (bossValue[chaozRowBuffed] &gt;= 0){
            rowLabel[textRows] = bossLabel[chaozRowBuffed];
            rowIndex[textRows] = chaozRowBuffed;
            rowValue[textRows] = bossValue[chaozRowBuffed];
            textRows ++;
        }*/
    }
    if (bossValue[geezerRow]){
        rowLabel[textRows] = bossLabel[geezerRow];
        rowIndex[textRows] = geezerRow;
        rowValue[textRows] = bossValue[geezerRow];  // checks multiple other variables in Draw event
        textRows ++;
    }
    if (bossValue[pvzRow] &gt;= 0){
        rowLabel[textRows] = bossLabel[pvzRow];
        rowIndex[textRows] = pvzRow;
        rowValue[textRows] = bossValue[pvzRow];
        textRows ++;
    }
    if (bossValue[undertaleRow] &gt;= 0){
        rowLabel[textRows] = bossLabel[undertaleRow];
        rowIndex[textRows] = undertaleRow;
        rowValue[textRows] = bossValue[undertaleRow];
        textRows ++;
    }
    if (bossValue[touhouRow] &gt;= 0){
        rowLabel[textRows] = bossLabel[touhouRow];
        rowIndex[textRows] = touhouRow;
        rowValue[textRows] = bossValue[touhouRow];
        textRows ++;
    }
    if (bossValue[stage4Row]){
        rowLabel[textRows] = bossLabel[stage4Row];
        rowIndex[textRows] = stage4Row;
        rowValue[textRows] = bossValue[stage4Row];
        textRows ++;
    }
    if (bossValue[scribbleRow]){
        rowLabel[textRows] = bossLabel[scribbleRow];
        rowIndex[textRows] = scribbleRow;
        rowValue[textRows] = bossValue[scribbleRow];  // checks multiple other variables in Draw event
        textRows ++;
    }
}

if (textRows &lt; 1){instance_destroy();exit;}

// positioning
borderThick = 8;
topOffset = 68;
titleH = 70;
textYSpacing = 32;
/*  // Exporting record   (No longer necessary)
exportButtonH = 48;
exportButtonSelected = false;
exportButtonClicked = false;
exportButtonY = topOffset + (windowHeight - (exportButtonH*0.5));
*/
windowWidth = 660;
windowHeight = (titleH + textYSpacing*textRows); // + exportButtonH);
closeButtonW = sprite_get_width(sprMakerSettingsX);
closeButtonH = sprite_get_height(sprMakerSettingsX);
closeButtonX = (660 - (closeButtonW-1));
closeButtonY = (-1);
closeButtonSelected = false;
closeButtonClicked = false;

// colors
colDefault = c_white;
colBack = make_color_rgb(218, 227, 242);
colStatMissing = make_color_rgb(202, 0, 0);
colStatGood = make_color_rgb(60, 222, 0);
colStatBest = make_color_rgb(242, 224, 0);
colHasBuffed = make_color_rgb(230, 240, 32);

// movement
move = -1;
if (room == rTMM_ClearLobby){
    move = 0;  // don't move in clear lobby
}else{
    x = 400;
    y = 616;
    xstart = x;
    ystart = y;
}
surf = -4;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(surf)){
    surface_free(surf);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _closeButtonSelectedPrev = closeButtonSelected;
closeButtonSelected = false;

if (room != rTMM_ClearLobby){
    if (keyboard_check_pressed(vk_escape)){
        move = 1;
    }
    
    if (move == -1){
        y -= max(2, y/7);
        if (y &lt;= 1){
            y = 0;
            move = 0;
        }
    }else if (move == 1){
        y += 32 + 28*(y/608);
        if (y &gt;= ystart){
            instance_destroy();
        }
    }
    
    //"X" Button
    var _regionLeft = (x - windowWidth/2) + closeButtonX;
    var _regionTop = (y + topOffset) + closeButtonY;
    if (mouse_x &gt;= _regionLeft &amp;&amp; mouse_x &lt; (_regionLeft + closeButtonW) &amp;&amp; mouse_y &gt;= _regionTop &amp;&amp; mouse_y &lt; (_regionTop + closeButtonH)){
        if (!closeButtonSelected){
            closeButtonSelected = true;
            if (!_closeButtonSelectedPrev){
                audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            }
        }
        if (mouse_check_button_pressed(mb_left)){
            closeButtonClicked = true;
        }
        
        if (mouse_check_button_released(mb_left) &amp;&amp; closeButtonClicked){
            closeButtonClicked = false;
            audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
            move = 1;
        }
    }
    if (!mouse_check_button(mb_left)){
        closeButtonClicked = false;
    }
}

/*  // Exporting record   (No longer necessary)
if (!(instance_exists(objSettingsMenu) &amp;&amp; objSettingsMenu.y &lt;= 480 &amp;&amp; objSettingsMenu.move != 1) &amp;&amp; !(instance_exists(objPopup) &amp;&amp; (objPopup.y &gt;= 120 &amp;&amp; objPopup.move != 1)) &amp;&amp; ((room == rTMM_ClearLobby &amp;&amp; view_yview == 0) || (room != rTMM_ClearLobby &amp;&amp; move != -1))){
    mask_index = sprMakerGUIButton;
    if (place_meeting(x, (y + exportButtonY), objMouseClickCheck)){
        if (!exportButtonSelected){
            audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
            exportButtonSelected = true;
        }
    }else{
        exportButtonSelected = false;
    }
    
    if (exportButtonSelected &amp;&amp; mouse_check_button_pressed(mb_left)){
        exportButtonClicked = true;
        audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
    }
    if (exportButtonClicked &amp;&amp; mouse_check_button_released(mb_left)){
        scrExportRecord();
        exportButtonClicked = false;
        audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
    }
    
    if (!mouse_check_button(mb_left)){
        exportButtonClicked = false;
    }
    mask_index = -1;
}else{
    exportButtonSelected = false;
    exportButtonClicked = false;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(surf)){
    surface_free(surf);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// calculate for positioning
var _textLeft = 16;
var _textTop = titleH;
var _labelBuffer = 16;  // pixels of extra space between fight label and stat value

var _surfWidth = (windowWidth + 2*borderThick);
var _surfHeight = (windowHeight + 2*borderThick);
var _top = borderThick;
var _bottom = (_surfHeight - borderThick);
var _left = borderThick;
var _right = (_surfWidth - borderThick);

if (!surface_exists(surf)){
    surf = surface_create(_surfWidth, _surfHeight);
}

if (surface_exists(surf)){
    surface_set_target(surf);
    draw_clear_alpha(colBack, 1);  // background color
    
    //Border Edges
    draw_sprite_ext(sprMakerSettingsBorder, 0, _left, (_top-borderThick), (windowWidth/borderThick), 1, 0, c_white, 1);    // top
    draw_sprite_ext(sprMakerSettingsBorder, 0, _left, (_bottom+borderThick), (windowWidth/borderThick), -1, 0, c_white, 1);   // bottom
    draw_sprite_ext(sprMakerSettingsBorder, 1, (_left-borderThick), _top, 1, (windowHeight/borderThick), 0, c_white, 1);    // left
    draw_sprite_ext(sprMakerSettingsBorder, 1, (_right+borderThick), _top, -1, (windowHeight/borderThick), 0, c_white, 1);    //right
    //Border Corners
    draw_sprite_ext(sprMakerSettingsBorder, 2, (_left-borderThick), (_top-borderThick), 1, 1, 0, c_white, 1);     // TL
    draw_sprite_ext(sprMakerSettingsBorder, 2, (_left-borderThick), (_bottom+borderThick), 1, 1, 90, c_white, 1);     // BL
    draw_sprite_ext(sprMakerSettingsBorder, 2, (_right+borderThick), (_top-borderThick), 1, 1, 270, c_white, 1);    // TR
    draw_sprite_ext(sprMakerSettingsBorder, 2, (_right+borderThick), (_bottom+borderThick), 1, 1, 180, c_white, 1);    // BR
    //Border Around "X" (read from top left to bottom right)
    if (room != rTMM_ClearLobby){
        draw_sprite_ext(sprMakerSettingsBorderThin, 3, _left + (closeButtonX-6), _top + (closeButtonY-7), 1, 1, 0, c_white, 1);
        draw_sprite_ext(sprMakerSettingsBorderThin, 1, _left + (closeButtonX-6), _top + (closeButtonY), 1, closeButtonH/8, 0, c_white, 1);
        draw_sprite_ext(sprMakerSettingsBorderThin, 2, _left + (closeButtonX-5), _top + (closeButtonY + (closeButtonH-3)), 1, 1, 0, c_white, 1);
        draw_sprite_ext(sprMakerSettingsBorderThin, 0, _left + (closeButtonX), _top + (closeButtonY + (closeButtonH-2)), closeButtonW/8, 1, 0, c_white, 1);
        draw_sprite_ext(sprMakerSettingsBorderThin, 4, _left + (closeButtonX + (closeButtonW-1)), _top + (closeButtonY + (closeButtonH-2)), 1, 1, 0, c_white, 1);
        // draw the "X" button
        
        var _ind = 0;
        if (closeButtonSelected){
            if (closeButtonClicked){
                _ind = 2;
            }else{
                _ind = 1;
            }
        }else{
            _ind = 0;
        }
        draw_sprite(sprMakerSettingsX, _ind, _left + closeButtonX, _top + closeButtonY);
    }
    
    // text attributes
    draw_set_valign(fa_top);
    draw_set_halign(fa_center);
    draw_set_color(c_black);
    
    draw_set_color(c_white);
    draw_set_font(fDefault24);
    draw_text_outline(_surfWidth/2, (_top + 20), "Challenges", 4, c_black, 16);
    
    draw_set_halign(fa_left);
    draw_set_font(fDefault16);
    var _charHeight16 = string_height("M");  // for checkboxes - use fDefault16
    
    // draw row(s)
    for (var i=0; i&lt;textRows; i++){
        draw_set_color(c_white);
        
        var _labelStr = string(bossLabel[rowIndex[i]]) + ":";
        var _statStr = "";
        var _hasBuffed = (rowIndex[i] == beelzRow || rowIndex[i] == chaozRow || rowIndex[i] == geezerRow || rowIndex[i] == scribbleRow);
        if (rowIndex[i] == beelzRow || rowIndex[i] == chaozRow || rowIndex[i] == undertaleRow || rowIndex[i] == touhouRow){  // Hit counts
            var _hits = rowValue[i];
            if (_hits != ceil(_hits)){  // ????
                show_debug_message("Value for row " + string(i) + " (" + string(_hits) + ") is not an integer");
                rowValue[i] = ceil(rowValue[i]);
            }
            
            var _buffedClear = ((rowIndex[i] == beelzRow &amp;&amp; global.beelzHardHitLowest &gt;= 0) || (rowIndex[i] == chaozRow &amp;&amp; global.chaozHardHitLowest &gt;= 0));
            if (_buffedClear){
                var _hitsBuffed = -1;
                if (rowIndex[i] == beelzRow){
                    _hitsBuffed = global.beelzHardHitLowest;
                }else if (rowIndex[i] == chaozRow){
                    _hitsBuffed = global.chaozHardHitLowest;
                }
                
                if (_hitsBuffed &gt;= 0){
                    if (_hits &gt;= 0 &amp;&amp; _hits &lt; _hitsBuffed){
                        _statStr += scrLabelNumber(_hits, "Hit", "Hits", "Hitless");
                    }
                    if (_statStr != ""){
                        _statStr += "  /  ";
                    }
                    _statStr += ("Buffed " + scrLabelNumber(_hitsBuffed, "Hit", "Hits", "Hitless"));
                    if (_hitsBuffed == 0){
                        draw_set_color(colStatBest);
                    }
                }else{
                    _statStr = scrLabelNumber(_hits, "Hit", "Hits", "Hitless");
                }
            }else if (_hits &gt;= 0){
                _statStr = scrLabelNumber(_hits, "Hit", "Hits", "Hitless");
                if (!_hasBuffed &amp;&amp; _hits == 0){
                    draw_set_color(colStatBest);
                }
            }else{
                _statStr = "No Record";
                draw_set_color(colStatMissing);
            }
        }else if (rowIndex[i] == pvzRow){  // Time
            if (global.pvzFastest &gt; 0){
                _statStr = scrFramesToTimer(global.pvzFastest, 50, true, 2);
            }else{
                _statStr = "No Record";
                draw_set_color(colStatMissing);
            }
        }else if (rowIndex[i] == geezerRow || rowIndex[i] == scribbleRow || rowIndex[i] == stage4Row){  // Checkboxes
            if (rowValue[i]){  // content was beaten normally
                _statStr = "";  // "Cleared";
                var _strW = (string_width(_labelStr) + _labelBuffer);  // should use fDefault16
                var _strRight = (_left + (_textLeft + _strW));
                var _leftPos = _strRight;
                var _yPos = floor(_top + (_textTop + textYSpacing*i) + _charHeight16/2) - 2;
                var _textYCorr = 2;
                
                var _checkboxSpace = (20 + 4);  // between checkbox and its condition
                var _conditionBuffer = 16;  // extra space between condition and next checkbox
                var _conditionStr = "";
                var _checkInd = 0;
                draw_set_font(fDefault12);
                draw_set_valign(fa_middle);
                //row-specific
                if (rowIndex[i] == geezerRow){
                    if (global.geezerNosaveCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "No Checkpoint";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + 14);
                    if (global.geezerNohitCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "No Hit (Shield)";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                    
                    _checkInd = 0;
                    if (global.geezerHardCompleted){
                        _checkInd = 1;
                        _conditionStr = "Buffed";
                    }else{
                        if (global.geezerPerfectCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                        _conditionStr = "Both";
                    }
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    //_conditionStr set above
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                }else if (rowIndex[i] == scribbleRow){
                    if (global.scribblePerfectCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "No Checkpoints";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                    
                    if (global.scribbleHardCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "Buffed";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                    
                    if (global.scribbleHardPerfectCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "Buffed No Checkpoints";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                }else if (rowIndex[i] == stage4Row){
                    if (global.stage4SavelessCompleted){_checkInd = 1;draw_set_color(colStatBest);}else{_checkInd = 0;draw_set_color(colDefault);}
                    draw_sprite(sprMakerSettingsCheckbox, (2 + _checkInd), _leftPos + 10, _yPos);
                    _leftPos += _checkboxSpace;
                    _conditionStr = "No Checkpoints";
                    draw_text_outline(_leftPos, _yPos + _textYCorr, _conditionStr, 2, c_black, 8);
                    _leftPos += (string_width(_conditionStr) + _conditionBuffer);
                    
                }
                draw_set_font(fDefault16);
                draw_set_valign(fa_top);
            }else{
                _statStr = "Not Cleared";
                draw_set_color(colStatMissing);
            }
        }else if (rowIndex[i] == stage4Row){
            if (rowValue[i]){  // fight was beaten
                _statStr = "Complete";
            }else if (max(global.farthestRoom, global.farthestRoomEver) &gt; scrGetRoomNum(rStage04New_4)){
                _statStr = "Not Cleared";
            }else{
                _statStr = "Not Cleared";
            }
        }
        
        if (_labelStr != ""){
            if (_hasBuffed){
                draw_set_color(colHasBuffed);
            }else{
                draw_set_color(colDefault);
            }
            draw_text_outline(_left + _textLeft, _top + (_textTop + textYSpacing*i), _labelStr, 3, c_black, 16);
        }
        if (_statStr != ""){
            if (_statStr == "Not Cleared" || _statStr == "No Record"){
                draw_set_color(colStatMissing);
            }else if (_statStr == "Hitless (Buffed)" || _statStr == "Hitless"){
                if (_hasBuffed &amp;&amp; _statStr == "Hitless"){
                    draw_set_color(colStatGood);
                }else{
                    draw_set_color(colStatBest);
                }
            }else if (rowIndex[i] == pvzRow){
                //probably should calculate frames with seconds
                var _time = rowValue[i];
                
                /*if (_time &gt; _goodThreshold){
                    draw_set_color(colDefault);
                }else */
                if (_time &lt;= global.pvzTargetTime){
                    draw_set_color(colStatBest);
                }else{
                    draw_set_color(colDefault);
                    _statStr += "  (Target: 3:45)";
                }
            }else{
                draw_set_color(colDefault);
            }
            
            draw_text_outline(round(_left + (_textLeft + (string_width(_labelStr) + _labelBuffer))), round(_top + (_textTop + textYSpacing*i)), _statStr, 3, c_black, 16);
        }
    }
    surface_reset_target();
    
    if (surface_exists(surf)){
        draw_surface(surf, x - _surfWidth/2, y + topOffset - borderThick);
    }
}
draw_set_color(c_white);

/*  // Exporting record   (No longer necessary)
// export button  (the index can change every frame, so we will draw it separate from the surface
if (exportButtonSelected){
    if (exportButtonClicked){
        draw_sprite(sprMakerGUIButton, 2, x, y + exportButtonY);
    }else{
        draw_sprite(sprMakerGUIButton, 1, x, y + exportButtonY);
    }
}else{
    draw_sprite(sprMakerGUIButton, 0, x, y + exportButtonY);
}
//draw_sprite(sprMakerMenuTextSmall, 2, x, y + exportButtonY);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
