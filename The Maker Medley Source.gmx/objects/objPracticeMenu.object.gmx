<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1300</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables
menuHeight = 576;

//scrolling
scrollYPos = 0;
scrollYAmt = 0;
scrollSelected = 0;
scrollClicked = 0; //0 = not clicked; 1 = drag the bar; 2 = move towards the cursor
scrollClickYOff = 0;

//scroll bar
scrollBarHeight = menuHeight;
scrollBarY = 0;
scrollbarWidth = 17;
scrollbarWidthShown = 0;

listSurf = noone;
clickedBoss = -1;
clickedPhase = -1;
selectedBoss = -1;
selectedPhase = -1;
selectedBossPrev = -1;
selectedPhasePrev = -1;

//reset variables we DON'T want to persist
for(var i=global.undertaleMax-1; i&gt;=0;i--){
    global.undertalePracticingIndex[i] = -1;
}
global.undertalePracticingNum = 0;

practChosenPhaseStart = -1;
practChosenBoss = -1;
numBoxes = 0;
maxOnscreenBoxes = 7;
for(i=maxOnscreenBoxes-1; i&gt;=0; i--){
    shownBoss[i] = 0;
    shownPhase[i] = 0;
}

listCol = make_color_rgb(71, 86, 135);
listColSelect = make_color_rgb(87, 102, 150);
listColClick = make_color_rgb(63, 67, 117);

playlistCol = make_color_rgb(37, 91, 80);
playlistColSelect = make_color_rgb(42, 104, 91);
playlistColClick = make_color_rgb(30, 73, 64);

inplaylistCol = make_color_rgb(57, 89, 112);
inplaylistColSelect = make_color_rgb(77, 107, 131);
inplaylistColClick = make_color_rgb(44, 65, 81);

instance_create(0, 0, objPracticeDifficultySwitch);

event_user(2);  // Boss Marker Info
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(listSurf))
    surface_free(listSurf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//calculate number of boxes shown
event_user(0);
var _scrollbar = (shownBoss[6] != -1 || numBoxes &gt;= 7);
if (_scrollbar){
    //scroll speed
    if (!instance_exists(objPopup) &amp;&amp; !instance_exists(objScreenFade)){
        if (mouse_wheel_up() &amp;&amp; mouse_wheel_down()){
            //Do nothing. How/Why would you do this?
        }else if (mouse_wheel_up()){
            if (scrollYAmt &lt; 30){
                scrollYAmt = 30;
            }else if (scrollYAmt &lt; 45){
                scrollYAmt = min(scrollYAmt + 7, 45);
            }
        }else if (mouse_wheel_down()){
            if (scrollYAmt &gt; -30){
                scrollYAmt = -30;
            }else if (scrollYAmt &gt; -45){
                scrollYAmt = max(scrollYAmt - 7, -45);
            }
        }
    }
    
    scrollbarWidthShown = min(scrollbarWidthShown + 0.1, 1);
    scrollBarHeight = menuHeight/max(1, numBoxes/6);
}else{
    scrollbarWidthShown = max(scrollbarWidthShown - 0.1, 0);
    scrollYAmt = 0;  //reset scroll bar
}

//dragging scroll bar
if (_scrollbar){
    if (!instance_exists(objPopup) &amp;&amp; !instance_exists(objScreenFade) &amp;&amp; (!instance_exists(objTitlePracticeInfo) || (instance_exists(objTitlePracticeInfo) &amp;&amp; objTitlePracticeInfo.fade == -1))){
        if (((mouse_x &gt;= 688 &amp;&amp; mouse_x &lt; (688 + (scrollbarWidth*scrollbarWidthShown)) &amp;&amp; mouse_y &gt;= 16 &amp;&amp; mouse_y &lt; 16 + 96*6) || scrollClicked == 1)){ //scroll bar
            if (mouse_check_button(mb_left)){
                var _relativeMouseY = (mouse_y - 16);
                var _scrollbarEdge = 3;
                
                //normal scrolling
                if (scrollClicked == 0 &amp;&amp; mouse_check_button_pressed(mb_left)){
                    audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
                    if (_relativeMouseY &gt;= scrollBarY &amp;&amp; _relativeMouseY &lt; scrollBarY + scrollBarHeight){
                        scrollClicked = 1;
                        scrollClickYOff = scrollBarY - _relativeMouseY;
                    }else{
                        scrollClicked = 2;
                    }
                }
                
                if (scrollClicked == 1){
                    scrollBarY = _relativeMouseY + scrollClickYOff;
                }else if (scrollClicked == 2){
                    if (_relativeMouseY &lt; scrollBarY){
                        scrollBarY = max(_relativeMouseY - _scrollbarEdge, scrollBarY - 8);
                    }else if (_relativeMouseY &gt;= (scrollBarY + scrollBarHeight)){
                        scrollBarY = min((_relativeMouseY - _scrollbarEdge) - scrollBarHeight, scrollBarY + 8);
                    }
                }
                scrollBarY = clamp(scrollBarY, 0, menuHeight - scrollBarHeight);
                scrollYPos = lerp(0, -96*max(0, numBoxes-6), scrollBarY/(menuHeight-scrollBarHeight));
                scrollYAmt = 0;
            }
            if (scrollSelected == 0){  // don't play select sound if we are also playing the click sound
                audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                scrollSelected = 1;
            }
        }else{
            if (scrollClicked != 0){
                audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
                scrollClicked = 0;
            }
            scrollSelected = 0;
        }
    }
    
    //update the scroll bar values
    if (scrollYAmt != 0){
        scrollYPos += scrollYAmt;
        if (abs(scrollYAmt) &lt;= 5){
            scrollYAmt = 0;
        }else{
            scrollYAmt -= 5*sign(scrollYAmt);
        }
    }
    
    scrollYPos = clamp(scrollYPos, -96*max(0, numBoxes - 6), 0);
    scrollBarY = (menuHeight - scrollBarHeight) * (-scrollYPos/(96*max(numBoxes - 6, 1)));
}

if (!mouse_check_button(mb_left)){
    scrollClicked = 0;
    scrollClickYOff = 0;
}

var i, _listIndex;
//Scroll if necessary
var _scrollOffset = (scrollYPos mod 96);
if (abs(_scrollOffset) &gt;= 96){ //gamemaker modulo errors
    _scrollOffset = 0;
}

//determine which rooms to show
event_user(1);

//selecting level boxes
selectedBossPrev = selectedBoss;
selectedPhasePrev = selectedPhase;
selectedBoss = -1;
selectedPhase = -1;
selectedSlot = -1;

if (!instance_exists(objPopup) &amp;&amp; !instance_exists(objScreenFade) &amp;&amp; (!instance_exists(objTitlePracticeInfo) || (instance_exists(objTitlePracticeInfo) &amp;&amp; objTitlePracticeInfo.fade == -1))){
    if (mouse_x &gt;= 16 &amp;&amp; mouse_x &lt; 688 &amp;&amp; mouse_y &gt;= 16 &amp;&amp; mouse_y &lt; 592){ //level boxes
        for(var i=6; i&gt;=0; i--){
            if (shownBoss[i] &gt;= 0 &amp;&amp; shownPhase[i] &gt;= 0){
                if (mouse_y &gt;= 96*i + (_scrollOffset) + 16 &amp;&amp; mouse_y &lt; 96*i + (_scrollOffset) + 112){
                    selectedSlot = i;
                    selectedBoss = shownBoss[selectedSlot];
                    selectedPhase = shownPhase[selectedSlot];
                    if (selectedBoss != selectedBossPrev || selectedPhase != selectedPhasePrev){
                        audio_stop_sound(sndMakerMenuSelect);
                        audio_play_sound_nogroup(sndMakerMenuSelect, 0, 0);
                    }
                }
            }
        }
    }
    //clicking
    //if (clickedBoss == -1){
    if (selectedBoss != -1){
        if (mouse_check_button_pressed(mb_left)){
            clickedBoss = selectedBoss;
            clickedPhase = selectedPhase;
            audio_play_sound_nogroup(sndMakerMenuClick, 0, 0);
        }
    }
    //}
    if (clickedBoss != -1 &amp;&amp; selectedBoss != -1){
        if (mouse_check_button_released(mb_left)){// &amp;&amp; clickedBoss == selectedBoss &amp;&amp; clickedPhase == selectedPhase){
            if (clickedBoss == selectedBoss &amp;&amp; clickedPhase == selectedPhase){
                if (clickedPhase &gt; 0){  // attack
                    if (practChosenBoss != selectedBoss || practChosenPhaseStart == -1 || selectedBoss == 3){ //allow the player to select more than 2 attacks in Undertale
                        practChosenBoss = selectedBoss
                        practChosenPhaseStart = selectedPhase;
                        
                        if (clickedBoss == 3){
                            var _clickedBoxTwice = false;
                            for (var i=0;i&lt;global.undertalePracticingNum;i++){
                                if (global.undertalePracticingIndex[i] + 1 == selectedPhase){
                                    _clickedBoxTwice = true;
                                }
                            }
                            if (_clickedBoxTwice){
                                scrPracticeStart(practChosenBoss, 0, 0);
                            }else{
                                global.undertalePracticingNum ++;
                                global.undertalePracticingIndex[global.undertalePracticingNum-1] = selectedPhase-1;
                            }
                         }else{
                            if (global.undertalePracticingNum &gt; 0){
                                for (var i=0;i&lt;global.undertalePracticingNum;i++){
                                    global.undertalePracticingIndex[i] = -1;
                                }
                                global.undertalePracticingNum = 0;
                            }
                         }
                    }else{
                        scrPracticeStart(practChosenBoss, min(practChosenPhaseStart, selectedPhase)-1, max(practChosenPhaseStart, selectedPhase));
                        for (var i=9; i&gt;=0; i--){
                            global.practiceFinalBossVal[i] = 0;
                            global.practiceFinalBossVal2[i] = 0;
                        }
                    }
                }else{  // playlist
                    bossExpanded[selectedBoss] = !bossExpanded[selectedBoss];
                    //redetermine number of boxes, and which rooms to show
                    event_user(0);
                    
                    //fix the scroll bar
                    scrollYPos = clamp(scrollYPos, -96*max(0, numBoxes - 6), 0);
                    scrollBarY = lerp(0, 576 - scrollBarHeight, -scrollYPos/(96*max(numBoxes - 6, 1)));
                    
                    event_user(1);
                    clickedBoss = -1;
                }
            }
            audio_play_sound_nogroup(sndMakerMenuRelease, 0, 0);
        }else{
            if (!mouse_check_button(mb_left)){
                clickedBoss = -1;
            }
        }
    }
    if (practChosenBoss &gt; -1 &amp;&amp; practChosenPhaseStart &gt; -1 &amp;&amp; mouse_check_button_pressed(mb_right)){
        practChosenBoss = -1;
        practChosenPhaseStart = -1;
        audio_play_sound(sndMakerRoomRestart, 0, 0);
        
        if (global.undertalePracticingNum &gt; 0){
            for (var i=0;i&lt;global.undertalePracticingNum;i++){
                global.undertalePracticingIndex[i] = -1;
            }
            global.undertalePracticingNum = 0;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Boss Marker Info
bosses = 6;
bossRoom[5] = scrGetRoomNum(rFinalBoss_1);
bossRoom[4] = scrGetRoomNum(rStage03Hub);
bossRoom[3] = scrGetRoomNum(rStage03Hub);
bossRoom[2] = scrGetRoomNum(rGeezer01);
bossRoom[1] = scrGetRoomNum(rChaozB);
bossRoom[0] = scrGetRoomNum(rStage01Purify);

undertaleCompleted = (global.farthestRoomEver &gt; bossRoom[3]);
touhouCompleted = (global.farthestRoomEver &gt; bossRoom[4]);

bossMarkersMax = max(global.bossMarkers[0], global.bossMarkers[1], global.bossMarkers[2], global.bossMarkers[3], global.bossMarkers[4], global.bossMarkers[5]);
bossProgress[bosses-1] = 0;
farthestBoss = -1;

//Find farthest boss reached
if (global.farthestRoomEver &gt;= bossRoom[5]){
    undertaleCompleted = true;
    touhouCompleted = true;
    
    farthestBoss = 5;
    bossProgress[farthestBoss] = clamp(global.finalBossFarthest + 1, 1, global.bossMarkers[farthestBoss]);
}else if (global.farthestRoomEver &gt;= scrGetRoomNum(rStage03Hub)){
    //note that Undertale(3) and Touhou(4) are reached simultaneously
    undertaleCompleted = (global.saveSRCoin[1] || global.undertaleHitLowest &gt;= 0);
    touhouCompleted = (global.saveSRCoin[2] || global.touhouHitLowest &gt;= 0);
    
    if (undertaleCompleted){
        bossProgress[3] = global.bossMarkers[3];
    }else{
        bossProgress[3] = 0;
        for (var i=0; i&lt;global.bossMarkers[3]; i++){
            if (global.undertaleEncountered[i] == 1){
                bossProgress[3] ++;
            }
        }
        bossProgress[3] = clamp(bossProgress[3], 1, global.bossMarkers[3]);
    }
    
    if (touhouCompleted){
        bossProgress[4] = global.bossMarkers[4];
    }else{
        bossProgress[4] = clamp(global.touhouFarthest + 1, 1, global.bossMarkers[4]);
    }
    
    farthestBoss = 4;
}else if (global.farthestRoomEver &gt;= bossRoom[2]){
    farthestBoss = 2;
    bossProgress[farthestBoss] = clamp(global.geezerFarthest + 1, 1, global.bossMarkers[farthestBoss]);
}else if (global.farthestRoomEver &gt;= bossRoom[1]){
    farthestBoss = 1;
    bossProgress[farthestBoss] = clamp(global.chaozFarthest + 1, 1, global.bossMarkers[farthestBoss]);
}else if (global.farthestRoomEver &gt;= bossRoom[0]){
    farthestBoss = 0;
    bossProgress[farthestBoss] = clamp(global.beelzFarthest + 1, 1, global.bossMarkers[farthestBoss]);
}else{
    room_goto(rTitle);  //the player shouldn't have been able to open this menu
}

// Unlock all attacks in completed bosses
for (var i=0; i&lt;bosses; i++){
    if (global.farthestRoomEver &gt; bossRoom[i]){
        bossProgress[i] = global.bossMarkers[i];
    }
}

for (var i = (bosses-1); i&gt;=0; i--){
    bossExpanded[i] = false; //Beelz, Chaoz, Geezer, Undertale, Touhou, Final
    for(var j=bossMarkersMax; j&gt;=0; j--){
        bossMarkerName[i, j] = "";
        bossMarkerDesc[i, j] = "";
        bossMarkerIcon[i, j] = 0; //j position 0 will use the objLoadGameMenu icons; all others will use a different sprite made for this menu
    }
}

bossSlotsCumulative[bosses-1] = 0;  // initialize the array
bossSlotsCumulative[0] = bossProgress[0];
for(var i=1; i&lt;=bosses-1; i++){
    bossSlotsCumulative[i] = bossSlotsCumulative[i-1] + bossProgress[i];
}

if (global.practPrevBoss &gt; farthestBoss){
    global.practPrevBoss = -1;
}

// Set up initial state
if (global.practPrevBoss &gt;= 0){  // make the menu automatically scroll down to the boss
    bossExpanded[global.practPrevBoss] = true;
    
    if (global.practPrevBoss &gt;= 1){
        event_user(0);
        
        if (numBoxes &gt; 6){
            scrollYPos = clamp((global.practPrevBoss + max(global.practPrevPhase - 4, 0)) / (numBoxes-6), 0, 1) * (-96*max(0, numBoxes-6));
            scrollBarY = clamp((-scrollYPos) - scrollBarHeight, 0, menuHeight - scrollBarHeight);
        }
    }
}else{
    for (var i = farthestBoss; i&gt;0; i--){
        bossExpanded[i] = (bossRoom[i] &gt; global.farthestRoomEver);  // Beelz, Chaoz, Geezer, Undertale, Touhou, Final
    }
    
    event_user(0);
    if (numBoxes &gt; 6){
        scrollYPos = clamp(farthestBoss / (numBoxes-6), 0, 1) * (-96*max(0, numBoxes-6));
        scrollBarY = clamp((-scrollYPos) - scrollBarHeight, 0, menuHeight - scrollBarHeight);
    }
}
scrollBarHeight = menuHeight/max(1, numBoxes/6);

// make the scrollbar completely visible if we should start with it present
event_user(0);
if (numBoxes &gt; 6){
    scrollbarWidthShown = 1;
}

//      BEELZEBUB       \\
bossMarkerName[0, 0] = "Fly of Beelzebub";
bossMarkerIcon[0, 0] = scrGetRoomInfo(rStage01Purify, 3);
bossMarkerName[0, 1] = "Introduction";
bossMarkerIcon[0, 1] = 0;
bossMarkerName[0, 2] = "Cherry Spirals";
bossMarkerIcon[0, 2] = 1;
bossMarkerName[0, 3] = "Bouncing Killer Block";
bossMarkerIcon[0, 3] = 2;
bossMarkerName[0, 4] = "Spring";
bossMarkerIcon[0, 4] = 3;
bossMarkerName[0, 5] = "Infinite Jump";
bossMarkerIcon[0, 5] = 4;

//        CHAOZ         \\
bossMarkerName[1, 0] = scrGetRoomInfo(rChaozB, 0);
bossMarkerIcon[1, 0] = scrGetRoomInfo(rChaozB, 3);
bossMarkerName[1, 1] = "Introduction";
bossMarkerIcon[1, 1] = 5;
bossMarkerName[1, 2] = "Chaoz Area";
bossMarkerIcon[1, 2] = 6;
bossMarkerName[1, 3] = "Platforming";
bossMarkerIcon[1, 3] = 7;
bossMarkerName[1, 4] = "Avoidance-R";
bossMarkerIcon[1, 4] = 8;
bossMarkerName[1, 5] = "Second Chaoz Area";
bossMarkerIcon[1, 5] = 9;
bossMarkerName[1, 6] = "The Final Cosmos";
bossMarkerIcon[1, 6] = 10;
bossMarkerName[1, 7] = "Shoot the Shurkien";
bossMarkerIcon[1, 7] = 11;
bossMarkerName[1, 8] = "Final Chaoz Area";
bossMarkerIcon[1, 8] = 12;

//        GEEZER        \\
bossMarkerName[2, 0] = scrGetRoomInfo(rGeezer01, 0);
bossMarkerIcon[2, 0] = scrGetRoomInfo(rGeezer01, 3);
bossMarkerName[2, 1] = "Mega Man Adventure";
bossMarkerIcon[2, 1] = 13;
bossMarkerName[2, 2] = "Klamy Pacman";
bossMarkerIcon[2, 2] = 14;
bossMarkerName[2, 3] = "Hitchcock";
bossMarkerIcon[2, 3] = 15;
bossMarkerName[2, 4] = "Climb";
bossMarkerIcon[2, 4] = 16;
bossMarkerName[2, 5] = "Now Geezer is Mad!";
bossMarkerIcon[2, 5] = 17;

//     UNDERTALE    \\
bossMarkerName[3, 0] = "Undertale Rip-off";
bossMarkerIcon[3, 0] = scrGetRoomInfo(rStage03Undertale, 3);
bossMarkerName[3, 1] = "Top rounded bullets";
bossMarkerIcon[3, 1] = 18;
bossMarkerName[3, 2] = "Fruit circles";
bossMarkerIcon[3, 2] = 19;
bossMarkerName[3, 3] = "Bouncing fruit";
bossMarkerIcon[3, 3] = 20;
bossMarkerName[3, 4] = "Upward moving fruit";
bossMarkerIcon[3, 4] = 21;
bossMarkerName[3, 5] = '"Generic Corridor Needle"';
bossMarkerIcon[3, 5] = 22;
bossMarkerName[3, 6] = '"Needle with a picture"';
bossMarkerIcon[3, 6] = 23;
bossMarkerName[3, 7] = '"Recreation of a boss"';
bossMarkerIcon[3, 7] = 24;
bossMarkerName[3, 8] = '"An avoidance"';
bossMarkerIcon[3, 8] = 25;
bossMarkerName[3, 9] = 'Precision needle';
bossMarkerIcon[3, 9] = 26;

//      TOUHOU      \\
bossMarkerName[4, 0] = "Touhou Rip-off";
bossMarkerIcon[4, 0] = scrGetRoomInfo(rStage03Touhou, 3);
bossMarkerName[4, 1] = "First rainbow kunai";
bossMarkerIcon[4, 1] = 27;
bossMarkerName[4, 2] = "Geyser";
bossMarkerIcon[4, 2] = 28;
bossMarkerName[4, 3] = "Second rainbow kunai";
bossMarkerIcon[4, 3] = 29;
bossMarkerName[4, 4] = "Yellow and orange circles";
bossMarkerIcon[4, 4] = 30;
bossMarkerName[4, 5] = "Purple aimed kunai";
bossMarkerIcon[4, 5] = 31;
bossMarkerName[4, 6] = "(Pseudo-)random(360)";
bossMarkerIcon[4, 6] = 32;
bossMarkerName[4, 7] = "Third rainbow kunai";
bossMarkerIcon[4, 7] = 33;
bossMarkerName[4, 8] = "Curving circles";
bossMarkerIcon[4, 8] = 34;
bossMarkerName[4, 9] = "Avoidance";
bossMarkerIcon[4, 9] = 35;

//     SCRIBBLE     \\
bossMarkerName[5, 0] = "Final Boss";
bossMarkerIcon[5, 0] = scrGetRoomInfo(rFinalBoss_1, 3);
bossMarkerName[5, 1] = "First Dev Appearances";
bossMarkerIcon[5, 1] = 36;
bossMarkerName[5, 2] = "Kadykunde";
bossMarkerIcon[5, 2] = 37;
bossMarkerName[5, 3] = "kurath";
bossMarkerIcon[5, 3] = 38;
bossMarkerName[5, 4] = "YoYoYoDude1";
bossMarkerIcon[5, 4] = 39;
bossMarkerName[5, 5] = "patrickgh3";
bossMarkerIcon[5, 5] = 40;
bossMarkerName[5, 6] = "Dribix";
bossMarkerIcon[5, 6] = 41;
bossMarkerName[5, 7] = "Tralexium";
bossMarkerIcon[5, 7] = 42;
bossMarkerName[5, 8] = "Sudnep";
bossMarkerIcon[5, 8] = 43;
bossMarkerName[5, 9] = "Final Phase";
bossMarkerIcon[5, 9] = 44;
bossMarkerName[5, 10] = "Finale";
bossMarkerIcon[5, 10] = 45;


//     BUFFED ICONS     \\

// index 0 is the room preview used in objLoadGameMenu, and is not changed for any fights  (???)
for (var i=0; i&lt;bosses; i++){
    bossMarkerIconBuff[i, 0] = -1;
}

for (var i=0; i&lt;=2; i++){
    for(var j=1; j&lt;=global.bossMarkers[i]; j++){
        bossMarkerIconBuff[i, j] = bossMarkerIcon[i, j];
    }
}

//Undertale(3) and Touhou(4) do not have buffed modes, so they do not need buffed attack icons
//Because there are no buffed attack icons for two prior bosses, the Mr. Scribble fight's buffed attack icons will not line up with its normal attack icons
var _buffScribbleStart = (global.bossMarkers[0] + global.bossMarkers[1] + global.bossMarkers[2]);
for(var j=1; j&lt;=global.bossMarkers[5]; j++){
    bossMarkerIconBuff[5, j] = _buffScribbleStart + (j-1);
}

if (!instance_exists(objTitleSquareButton)){
    instance_create(800, 545, objTitleSquareButton);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///determine which bosses/phases to show
var _listIndex, _startingBox, _startingBoss, _startingPhase;

_listIndex = 0;
_startingBox = -(scrollYPos div 96);
_startingBoss = 0;
for(var i=0; i&lt;bosses; i++){
    if (!bossExpanded[i] &amp;&amp; ((i == 0 &amp;&amp; _startingBox &gt;= 0 + 1) || (i &gt;= 1 &amp;&amp; _startingBox &gt;= bossSlotsCumulative[i-1] + i + 1))){
        _startingBox += bossProgress[i];
    }
}
for(var i=bosses-1;i&gt;0;i--){
    if (_startingBox &gt;= bossSlotsCumulative[i-1] + i){
        _startingBoss = i;
        break;
    }
}

if (_startingBoss &gt; 0){
    _startingPhase = _startingBox - (bossSlotsCumulative[_startingBoss-1] + _startingBoss);
}else{
    _startingPhase = _startingBox;
}

for(var i = _startingBoss; i &lt; bosses &amp;&amp; _listIndex &lt; numBoxes; i++){
    if (i &gt;= 0 &amp;&amp; i &lt;= farthestBoss){
        if (!bossExpanded[i]){  // minimized
            shownBoss[_listIndex] = i;
            shownPhase[_listIndex] = 0;
            _listIndex ++;
        }else if (i == 3 &amp;&amp; !undertaleCompleted){  // 3 = undertale
            for(j = _startingPhase; j &lt;= global.bossMarkers[i]; j++){
                if (j &lt;= 1 || global.undertaleEncountered[j-1]){
                    shownBoss[_listIndex] = i;
                    shownPhase[_listIndex] = j;
                    _listIndex ++;
                }
            }
        }else{  // default            
            // boss attacks
            for(var j = _startingPhase; j &lt;= min(global.bossMarkers[i], bossProgress[i]) &amp;&amp; _listIndex &lt; numBoxes; j++){
                if (j == 0 || (bossExpanded[i] &amp;&amp; (i &lt; farthestBoss || j &lt;= (bossProgress[farthestBoss] + 1)))){
                    shownBoss[_listIndex] = i;
                    shownPhase[_listIndex] = j;
                    _listIndex ++;
                }
            }
        }
    }
    _startingPhase = 0;
}

for (var i = _listIndex; i &lt; 7; i++){
    shownBoss[i] = -1;
    shownPhase[i] = -1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///calculate total number of boxes
numBoxes = 0;
for(var i = 0; i &lt;= farthestBoss; i ++){
    if (bossExpanded[i]){
        numBoxes += min(bossProgress[i], global.bossMarkers[i]);
    }
    numBoxes ++; //+1 for the boss "playlist"
}

//scrollBarHeight = menuHeight/max(1, numBoxes/6);  // only update scrollBarHeight when the player can scroll
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(listSurf))
    surface_free(listSurf);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> var i, _scrollOffset;
_scrollOffset = (scrollYPos mod 96);
if (abs(_scrollOffset) &gt;= 96){ //gamemaker modulo errors (shouldn't happen with the `floor` function but who knows)
    _scrollOffset = 0;
}
var _surfaceWidth = 672 + (scrollbarWidth*scrollbarWidthShown);
var _surfHeight = min(menuHeight, 96*numBoxes);

if (!surface_exists(global.sharedSurf)){
    global.sharedSurf = surface_create(800, 608);
}
if (surface_exists(global.sharedSurf)){
    surface_set_target(global.sharedSurf);
    draw_clear_alpha(c_black, 0);
    
    var _minSelect, _maxSelect;
    if (practChosenBoss != -1 &amp;&amp; selectedBoss == practChosenBoss){
        _minSelect = clamp(selectedPhase, 1, practChosenPhaseStart);
        _maxSelect = max(practChosenPhaseStart, selectedPhase);
    }else{
        _minSelect = practChosenPhaseStart;
        _maxSelect = practChosenPhaseStart;
    }
    
    //color the boxes
    draw_set_color(inplaylistCol);
    draw_rectangle(0, 0, 671, _surfHeight - 1, false); //background will be the unselected box
    //color in the selected box(es), if needed
    if (practChosenBoss == -1 &amp;&amp; selectedSlot &gt;= 0){
        if (clickedBoss == -1){
            draw_set_color(inplaylistColSelect);
        }else{
            draw_set_color(inplaylistColClick);
        }
        draw_rectangle(0, _scrollOffset + selectedSlot*96  + 0.5, 671, _scrollOffset + (selectedSlot+1)*96  + 0.5, false);
    }else{
        if (selectedBoss == global.practiceBoss){
            if (clickedBoss == -1){
                draw_set_color(inplaylistColSelect);
            }else{
                draw_set_color(inplaylistColClick);
            }
            
            for(var i=0;i&lt;min(numBoxes, maxOnscreenBoxes);i++){
                if (shownBoss[i] == selectedBoss &amp;&amp; shownPhase[i] &gt;= _minSelect &amp;&amp; shownPhase[i] &lt;= _maxSelect){
                    draw_rectangle(0, _scrollOffset + 96*i  + 0.5, 671, _scrollOffset + (i+1)*96  + 0.5, false);
                }
            }
        }else{
            draw_rectangle(0, _scrollOffset + practChosenPhaseStart*96  + 0.5, 671, _scrollOffset + (practChosenPhaseStart+1)*96  + 0.5, false);
        }
    }
    if (selectedSlot &gt;= 0){
        if ((clickedBoss == -1 || clickedBoss != selectedBoss || clickedPhase != selectedPhase) &amp;&amp; selectedPhase &gt; 0){
            draw_set_color(inplaylistColSelect);
            draw_rectangle(0, _scrollOffset + selectedSlot*96  + 0.5, 671, _scrollOffset + (selectedSlot+1)*96  + 0.5, false);
        }else if ((clickedBoss != -1 &amp;&amp; clickedBoss == selectedBoss) &amp;&amp; clickedPhase &gt;= 0){
            draw_set_color(inplaylistColClick);
            draw_rectangle(0, _scrollOffset + selectedSlot*96, 671, _scrollOffset + selectedSlot*96 + 95, false);
        }
    }
    
    //color in playlist boxes
    for(var i=0;i&lt;min(numBoxes, maxOnscreenBoxes);i++){
        if (shownPhase[i] == 0){
            if (shownBoss[i] == selectedBoss &amp;&amp; selectedPhase == 0){
                if (shownBoss[i] == clickedBoss &amp;&amp; clickedPhase == 0){
                    draw_set_color(playlistColClick);
                }else{
                    draw_set_color(playlistColSelect);
                }
            }else{
                draw_set_color(playlistCol);
            }
            draw_rectangle(0, _scrollOffset + i*96, 671, _scrollOffset + i*96 + 95, false);
        }
    }
    
    var t_boxHeight, t_roomPos, t_makerSpr, t_color, _listPercent;
    t_boxHeight = _scrollOffset;
    t_roomPos = "";
    t_makerSpr = 0;
    t_color = c_white;
    _listPercent = 0;
    draw_set_font(fPracticeMenu);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_color(c_white);
    
    //Text
    var _diffLerp, _textBuffCol;
    if (instance_exists(objPracticeDifficultySwitch)){
        _diffLerp = objPracticeDifficultySwitch.switchCurLerp;
        _textBuffCol = merge_colour(c_white, objPracticeDifficultySwitch.buffedTextCol, _diffLerp);
    }else{
        _diffLerp = 0;
        _textBuffCol = c_white;
    }
    
    for(var i=0; i&lt;min(numBoxes, maxOnscreenBoxes); i++){
        if (shownBoss[i] &gt;= 0 &amp;&amp; shownPhase[i] &gt;= 0){
            _hasBuffed = (shownBoss[i] != 3 &amp;&amp; shownBoss[i] != 4 &amp;&amp; shownBoss[i] &lt;= farthestBoss);
            if (_hasBuffed &amp;&amp; shownBoss[i] == 5){  // additional condition  (removed)
                //_hasBuffed = (shownPhase[i] &lt;= global.finalBossBuffPhases);
            }
            
            if (_hasBuffed){  // Undertale and Touhou don't have a "buffed" mode
                draw_set_color(_textBuffCol);
            }else{
                draw_set_color(c_white);
            }
            
            if (shownPhase[i] == 0){  // Boss Title
                draw_sprite(sprTitleStageIcon, bossMarkerIcon[shownBoss[i], 0], 0, 96*i + (_scrollOffset));
                draw_text_outline(400, _scrollOffset + i*96 + 48, bossMarkerName[min(shownBoss[i], bosses-1), min(shownPhase[i], global.bossMarkers[min(shownBoss[i], bosses-1)])], 4, c_black, 14);
            }else{  // Boss Phases
                if (_hasBuffed){
                    if (_diffLerp &lt; 1){
                        draw_sprite(sprPracticeAttacks, bossMarkerIcon[shownBoss[i], shownPhase[i]], 0, 96*i + (_scrollOffset));
                    }
                    if (_diffLerp &gt; 0){
                        draw_sprite_ext(sprPracticeAttacksBuffed, bossMarkerIconBuff[shownBoss[i], shownPhase[i]], 0, 96*i + (_scrollOffset), 1, 1, 0, c_white, _diffLerp);
                    }
                }else{
                    draw_sprite(sprPracticeAttacks, bossMarkerIcon[shownBoss[i], shownPhase[i]], 0, 96*i + (_scrollOffset));
                }
                draw_text_transformed_outline(400, _scrollOffset + i*96 + 48, bossMarkerName[min(shownBoss[i], bosses-1), min(shownPhase[i], global.bossMarkers[min(shownBoss[i], bosses-1)])], 4, c_black, 14, 0.667, 0.667, 0);
            }
        }
    }
    
    //Dividers
    draw_set_color(c_black);
    for(var i=1; i&lt;min(numBoxes, maxOnscreenBoxes); i++){
        draw_line(0, (_scrollOffset) + 96*i  -0.5, 672, (_scrollOffset) + 96*i  -0.5);
    }
    
    draw_line(127, 0, 127, _surfHeight);
    draw_set_color(c_white);
    
    //Selection highlights
    if (practChosenBoss == 3){ // Undertale
        for(var i=0; i &lt; min(numBoxes, maxOnscreenBoxes); i ++){
            if (shownBoss[i] == practChosenBoss){
                for (var j=0; j &lt; global.undertalePracticingNum; j ++){
                    if (shownPhase[i] == global.undertalePracticingIndex[j]+1){
                        draw_sprite(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i);
                        draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i, -1, 1, 0, c_white, 1);
                        draw_sprite_ext(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i + 97, 1, -1, 0, c_white, 1);
                        draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i + 97, -1, -1, 0, c_white, 1);
                        break;
                    }
                }
            }
        }
    }else if (practChosenBoss != -1){
        for(var i=0; i&lt;min(numBoxes, maxOnscreenBoxes); i++){
            if (shownBoss[i] == practChosenBoss){
                if (shownPhase[i] == _minSelect){
                    draw_sprite(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i);
                    draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i, -1, 1, 0, c_white, 1);
                }
                if (shownPhase[i] == _maxSelect){
                    draw_sprite_ext(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i + 97, 1, -1, 0, c_white, 1);
                    draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i + 97, -1, -1, 0, c_white, 1);
                }
            }
        }
    }else if (selectedBoss != -1 &amp;&amp; selectedPhase &gt; 0){
        for(var i=0; i&lt;min(numBoxes, maxOnscreenBoxes); i++){
            if (shownBoss[i] == selectedBoss &amp;&amp; shownPhase[i] == selectedPhase){
                draw_sprite(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i);
                draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i, -1, 1, 0, c_white, 1);
                draw_sprite_ext(sprMakerPracticeSelected, 0, 0, (_scrollOffset) + 96*i + 97, 1, -1, 0, c_white, 1);
                draw_sprite_ext(sprMakerPracticeSelected, 0, 672, (_scrollOffset) + 96*i + 97, -1, -1, 0, c_white, 1);
            }
        }
    }
    
    // fix slight transparency 
    draw_set_colour_write_enable(false, false, false, true);
    draw_rectangle(0, 0, 672, _surfHeight, false);
    draw_set_colour_write_enable(true, true, true, true);
    
    //Scroll bar
    if (scrollbarWidthShown &gt; 0){
        //Container
        draw_set_color(listColClick);
        draw_rectangle(672, 0, 688, _surfHeight-1, false);
        draw_set_color(c_black);
        draw_line(672, 0, 672, _surfHeight-.5);
        draw_set_color(c_white);
        
        //Bar
        var _scrollInd;
        if (scrollClicked != 0){
            _scrollInd = 2;
        }else if (scrollSelected != 0){
            _scrollInd = 1;
        }else{
            _scrollInd = 0;
        }
        
        var _drawnBarHeight = min(scrollBarHeight, _surfHeight);
        draw_sprite(sprMakerTitleScrollbar, _scrollInd*3, 673, 1 + scrollBarY);
        draw_sprite_stretched(sprMakerTitleScrollbar, _scrollInd*3 + 1, 673, 8 + scrollBarY, 16, (_drawnBarHeight - 16));
        draw_sprite(sprMakerTitleScrollbar, _scrollInd*3 + 2, 673, 0 + scrollBarY + _drawnBarHeight - 8);
        draw_sprite(sprMakerTitleScrollbar2, _scrollInd, 673, 0 + scrollBarY + (_drawnBarHeight/2) - 17);
    }
    surface_reset_target();
    
    //draw the list surface
    if (surface_exists(global.sharedSurf)){
        draw_surface_part(global.sharedSurf, 0, 0, _surfaceWidth, menuHeight, 16, 16);
        
        // surface outline
        draw_set_color(c_black);
        draw_rectangle(16, 16  -0.5, (16+_surfaceWidth)  +0.5, 16 + _surfHeight+0.5, true);
        draw_rectangle(17, 17  -0.5, (16+_surfaceWidth)  -0.5, 16 + _surfHeight-0.5, true);
        draw_set_color(c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
