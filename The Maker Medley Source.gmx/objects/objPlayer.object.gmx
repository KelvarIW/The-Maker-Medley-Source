<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //sets if the player can move or not

jump = 8.5 * global.grav; //set how fast the player jumps
jump2 = 7 * global.grav; //sets how fast the player double jumps
gravity = 0.4 * global.grav; //player gravity

djump = 1; //allow the player to double jump as soon as he spawns
maxSpeed = 3;   //max horizontal speed
maxVspeed = 9;  //max vertical speed
image_speed = 0.2; //initial speed of animation
image_index = global.countPersistent * image_speed;
onPlatform = false; //sets if player is currently standing on a platform
reverseCoyoteFrames = 0;
xScale = global.playerXScale; //sets the direction the player is facing (1 is facing right, -1 is facing left)

scrSetPlayerMask(); //set the player's hitbox

/*if (global.difficulty == 0 &amp;&amp; global.gameStarted)   //create the player's bow
    instance_create(x,y,objBow);
*/

//Custom variables
highGrav = false;
lowGrav = false;
lowGravVine = false;
highSpeed = false;
vinegrav = 0;
vinespeed = 0;
count = 0;
iframes = 0;
wasOnVine = false; //previous frame
inWater = noone;
inRift = noone;
fallingKid = 0; //for sprPlayerPreFall
coopTeleportUses = 1
springHForce = 0;
parachute = noone;
drawXOff = 0;
drawYOff = 0;
stage4ZeusTimerPleaseImSoTiredOfThis = 0;

//Better Blocks
riding = noone;
PhSpd = 0;
PvSpd = 0;
platCheck = 0;
platCounter = 0;
hPush = 0; //amount pushed by Better Blocks (used to carry the player)
moveLimit = 3; //used to be a local variable in the normal engine's Step event

//Version 1.1: used to store the relationship between the player's origin and their bbox
leftToOrigin = (sprite_get_xoffset(mask_index) - sprite_get_bbox_left(mask_index) + 1)*image_xscale;
rightToOrigin = (sprite_get_bbox_right(mask_index) - sprite_get_xoffset(mask_index) + 1)*image_xscale;
topToOrigin = (sprite_get_yoffset(mask_index) - sprite_get_bbox_top(mask_index) + 1)*image_yscale;
bottomToOrigin = (sprite_get_bbox_bottom(mask_index) - sprite_get_yoffset(mask_index) + 1)*image_yscale;

sprJump = sprPlayerJump;
sprRunning = sprPlayerRunning;
sprFall = sprPlayerFall;
sprIdle = sprPlayerIdle;

// Autosave
if (global.autosave){
    alarm[0] = 1;
}
// Snap to starting save on initial load; Position-based set-up
alarm[1] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//when the player is destroyed, also destroy the bow
with (objBow)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Snap to starting save when first loading room

//room-specific behavior for loading from load game/practice menu
var _roomPrevious = -1;
with (objWorld){
    _roomPrevious = roomPrevious;
}
if (_roomPrevious == rMenu || _roomPrevious == rPracticeMenu){
    // default position
    with (objPlayerStart){
        other.x = x + 17;
        other.y = y + 23;
    }
    var _useSaveCoords = ((room == rStage02Klamy &amp;&amp; global.roomSaveTo &gt; 1) || (room == rStage04New_3 &amp;&amp; (global.roomSaveTo == 2 &amp;&amp; global.S4KlamySaves == 0)));
    if (!_useSaveCoords){
        with (objMakerBossSave){
            if (alarm[1] &gt; 0){
                event_perform(ev_alarm, 1);
            }
        }
        with (objSave){event_user(2);}
        with (objMakerCamera){
            event_perform(ev_alarm, 0);  // update starting position if necessary
        }
    }else{
        x = global.savePlayerX;
        y = global.savePlayerY;
    }
    xprevious = x;
    yprevious = y;
    scrSaveGame(true);
    
    if (room == rStage02Klamy){
        global.klamySaveCurr = (max(global.roomSaveTo, 1)-1);
        global.saveKlamySaveCurr = global.klamySaveCurr;
    }
    if (room == rStage04New_3){
        if (global.S4KlamySaves == 1 || global.roomSaveTo &lt; 2){  // before the save section, or didn't use S4
            global.S4KlamySaveCurr = 0;
        }else{
            global.S4KlamySaveCurr = 1;
        }
        global.saveS4KlamySaveCurr = global.S4KlamySaveCurr;
    }
}

//position-based set-up
with (objMakerCamera){
    event_perform(ev_alarm, 0);  // Based on player placement
}
with (objS4NewDraw){
    event_perform(ev_alarm, 0);  // Based on player placement
}
if (room == rFinalBoss_4){
    with (objFinalBossDraw){
        event_perform(ev_alarm, 0);  // colorize background if in Sudnep avoidance
    }
}
    
//clean-up
alarm[1] = -1;  // in case it's set as an alarm
global.roomSaveTo = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Autosave
if (alarm[1] &gt; 0){
    event_perform(ev_alarm, 1);
    alarm[1] = -1;
}
if (!(room == rGeezerHitchcock &amp;&amp; global.challengeMode)){  // (failsafe) no autosave for buffed Geezer
    var _saveID = 1;
    if (room == rGeezerHitchcock){
        _saveID = 2; //unlock the second save
    }
    scrTMM_Autosave(x, y, _saveID);
    //make music identifier appear if the player starts the game in rStage03Hub
    if (room == rStage03Hub){
        with (objWorld){
            createMusicIdent = true;
        }
    }
    
    global.autosave = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Detect if player is offscreen
if (!instance_exists(objFinalBossChar_4)){ //a separate system is used for P4 to account for view rotation
    var _useViewBounds = (room == rChaozB || room == rFinalBoss_2);
    var _left = 0, _top = 0, _right = 800, _bottom = 608;
    if (_useViewBounds &amp;&amp; !instance_exists(objMakerTeleTransition)){
        _left = view_xview;
        _top = view_yview;
        _right = _left+view_wview;
        _bottom = _top+view_hview;
        
        // include target view in range
        with (objMakerCamera){
            if (!smoothCam){
                event_user(0);  // consistency despite instance event execution order
            }
            if (moveCam || smoothCam){
                _left = min(xTo, _left);
                _top = min(yTo, _top);
                _right = max(xTo+view_wview, _right);
                _bottom = max(yTo+view_hview, _bottom);
            }
        }
        if (room == rFinalBoss_2){
            _right = max(_right, 0+view_wview);  // for screen panning left
        }
    }else{
        _top = 0;
        _left = 0;
        _right = room_width;
        _bottom = room_height;
    }
    if ((x &lt; (_left-5) || x &gt; (_right+5) || y &lt; (_top-9) || y &gt; (_bottom+12)) &amp;&amp; global.edgeDeath &amp;&amp; !place_meeting(x,y,objGeezerPacScreenWrap)){  //check if player has left the room
        scrKillPlayer(); //treat it like a "hit"
        if (!global.dead &amp;&amp; (!global.debugNoDeath || global.shield &gt; 0 || iframes &gt; 0)){  //had a shield
            //since the player was hit
            if (global.infJump || _useViewBounds){  //Thankfully, Phase 1/2 of the Final Boss does not give the player a shield
                x = view_xview + 400;
                if (room == rStage01Purify){
                    if (instance_exists(objBeelzP03a)){
                        var _ang = objBeelzP03a.image_angle;
                        if (dcos(objBeelzP03a.image_angle) &gt; 0){
                            x -= 200;
                        }else{
                            x += 200;
                        }
                    }
                    if (instance_exists(objMakerLaser)){
                        if (x &lt; objMakerLaser.x){
                            x = max(min(objMakerLaser.x, 784), xprevious);
                        }
                    }
                    y = view_yview + 128;
                }else if (room == rChaozB &amp;&amp; view_yview == 0){
                    y = view_yview + 304;
                }else if (_useViewBounds){
                    y = view_yview + 80;
                }
                xprevious = x;
                yprevious = y;
            }else{ //need to place the player on a block
                x = 400;
                y = view_yview + 32;
                xprevious = x;
                yprevious = y;
                var _inst = scrMoveContactObject(0, 1, 608, objBlock);
                if (_inst == noone){  // failsafe
                    y = yprevious;
                }
            }
            
            if (!global.screenshotMode){
                var _col = make_color_rgb(206, 95, 91);
                repeat(irandom_range(14, 18)){
                    with (instance_create(x, y, objMakerCirclePart)){
                        color = _col;
                        curve = random_range(1.3, 2.78);
                    }
                }
                var _snd = audio_play_sound(sndMakerTeleport, 0, 0);
                audio_sound_pitch(_snd, PITCH_FLUCT);
                audio_sound_gain(_snd, 0.7, 0);
            }
        }
    }
}
//ADDED: instant acceleration for vvvvvv kid
if(global.playerV) 
{
    if(global.grav==1 &amp;&amp; vspeed !=0) { vspeed = maxVspeed;}
    if(global.grav==-1 &amp;&amp; vspeed !=0) { vspeed = -maxVspeed;}
}
    
//update player sprite
if (global.playerAnimationFix)
{
    image_speed = 0;
    //block/vine checks
    var notOnBlock = (place_free(x,y+(global.grav)) &amp;&amp; !instance_exists(riding));
    var onVineR = (place_meeting(x+1,y,objWalljumpR) &amp;&amp; notOnBlock);
    var onVineL = (place_meeting(x-1,y,objWalljumpL) &amp;&amp; notOnBlock);
    var onVineL2 = (place_meeting(x-1,y,objRedVineL) &amp;&amp; notOnBlock);
    var onVineR2 = (place_meeting(x+1,y,objRedVineR) &amp;&amp; notOnBlock);
    var onVineL3 = (place_meeting(x-1,y,objIceVineL) &amp;&amp; notOnBlock);
    var onVineR3 = (place_meeting(x+1,y,objIceVineR) &amp;&amp; notOnBlock);
    var onVineL4 = (place_meeting(x-1,y,objBlueVineL) &amp;&amp; notOnBlock);
    var onVineR4 = (place_meeting(x+1,y,objBlueVineR) &amp;&amp; notOnBlock);
    var onVineL5 = (place_meeting(x-1,y,objYellowVineL) &amp;&amp; notOnBlock);
    var onVineR5 = (place_meeting(x+1,y,objYellowVineR) &amp;&amp; notOnBlock);
    var onVineL6 = (place_meeting(x-1,y,objPurpleVineL) &amp;&amp; notOnBlock);
    var onVineR6 = (place_meeting(x+1,y,objPurpleVineR) &amp;&amp; notOnBlock);
    var onVineR7a = (place_meeting(x+1,y,objWhiteVineR) &amp;&amp; notOnBlock &amp;&amp; global.vine7=0);
    var onVineL7a = (place_meeting(x-1,y,objWhiteVineL) &amp;&amp; notOnBlock &amp;&amp; global.vine7=0);
    var onVineR7b = (place_meeting(x+1,y,objBlackVineR) &amp;&amp; notOnBlock &amp;&amp; global.vine7=1);
    var onVineL7b = (place_meeting(x-1,y,objBlackVineL) &amp;&amp; notOnBlock &amp;&amp; global.vine7=1);
    var onVineL8 = (place_meeting(x-1,y,objFireVineL) &amp;&amp; notOnBlock);
    var onVineR8 = (place_meeting(x+1,y,objFireVineR) &amp;&amp; notOnBlock);
    var onAnyVine = (onVineL || onVineR || onVineL2 || onVineR2 || onVineL3 || onVineR3 || onVineL4 || onVineR4 || onVineL5 || onVineR5 || onVineL6 || onVineR6 || onVineL7a || onVineR7a || onVineL7b || onVineR7b || onVineL8 || onVineR8);

    if (!onAnyVine)   //not touching any vines
    {
        if ((onPlatform || !notOnBlock) &amp;&amp; !instance_exists(objMakerBubble))  //standing on something
        {
            //check if moving left/right
            var L = (scrButtonCheck(global.leftButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
            var R = (scrButtonCheck(global.rightButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
            
            if ((L || R) &amp;&amp; !frozen)
            {
                sprite_index = sprPlayerRunning;
                image_speed = 1/2;
            }
            else
            {
                sprite_index = sprPlayerIdle;
                image_speed = 1/5;
            }
        }
        else    //in the air
        { 
            image_speed = 1/2;
            if((vspeed * global.grav) &lt; gravity-0.05) {sprite_index = sprJump;}
            else if((vspeed * global.grav) &gt;= gravity-0.05) {
                if (fallingKid &lt; 6){
                    sprite_index = sprPlayerPreFall;
                    image_index = fallingKid;
                    fallingKid += 0.5;
                }else sprite_index = sprFall;
            }
        }
    }
    else    //touching a vine
    {
        sprite_index = sprPlayerSliding;
        image_speed = 1/2;
    }
}

// keep animation frame consistent through restarts
if (sprite_index != sprPlayerPreFall){  //this sprite's animation needs to start at 0 and end at the final frame
    image_index = global.countPersistent * image_speed;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set up Player variables for objBetterBlock and objBetterMovingPlatform
PhSpd = (x - xprevious);
PvSpd = (y - yprevious);
//Version 1.1: used to store the relationship between the player's origin and their bbox
leftToOrigin = (sprite_get_xoffset(mask_index) - sprite_get_bbox_left(mask_index))*image_xscale;
rightToOrigin = (sprite_get_bbox_right(mask_index) - sprite_get_xoffset(mask_index) + 1)*image_xscale;
topToOrigin = (sprite_get_yoffset(mask_index) - sprite_get_bbox_top(mask_index))*image_yscale;
bottomToOrigin = (sprite_get_bbox_bottom(mask_index) - sprite_get_yoffset(mask_index) + 1)*image_yscale;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room == rStage02Abstr4ktNew){ //Stage 2 Abstr4kt screen
    if (global.abstr4ktGrav == 0){
        lowGrav = true;
        highGrav = false;
    }else{
        highGrav = true;
        lowGrav = false;
    }
}else if (room == rStage02Telejump){ //Stage 2 Telejump nerf
    lowGrav = true;
}else if (room == rStage04New_3){
    if (collision_rectangle(64, 0, 704, 192, id, false, false) == id){
        if (global.abstr4ktGrav == 0){
            lowGrav = true;
            highGrav = false;
        }else{
            highGrav = true;
            lowGrav = false;
        }
    }else{
        highGrav = false;
        lowGrav = false;
    }
}else if (room == rStage04New_4){
    if (collision_rectangle(64, 0, 400, 608, id, false, false) == id){
        lowGrav = true;
    }else{
        lowGrav = false;
    }
    highGrav = false;
}
// ADDED: Gravity, speed, jungle adventure

// Gravity fields
gravity = 0.4*global.grav;
if (place_meeting(x, y, objHighGravityField) || highGrav == true) {
    gravity = 0.7*global.grav;
} else if (place_meeting(x, y, objLowGravityField) || lowGrav == true) {
    gravity = 0.2*global.grav;
} else if (lowGravVine) {
    gravity = 0.3*global.grav;
}

if (image_yscale == 2) //big kid
    gravity = 0.7*global.grav;

//Water splashing
var _wasInWater;
_wasInWater = inWater;
inWater = instance_place(x, y, objWater);
if (inWater == noone)
    inWater = instance_place(x, y, objWater2);

if (_wasInWater == noone &amp;&amp; inWater != noone){
    repeat(irandom_range(5, 7)){
        with (instance_create(x, y, objMakerCirclePart)){
            color = c_white;
            direction = other.direction + irandom_range(167, 195);
            gravity = random_range(0.06, 0.11);
            speed = random_range(3.7, 5.5);
            rad = random_range(7, 10);
            water = true;
            //failsafe
            if (sign (vspeed) != sign(other.yprevious - (other.inWater.bbox_top + other.inWater.sprite_height/2))){
                vspeed *= -1;
            }
        }
    }
}

//Rift "splashing"  -- REMOVED
/*
var _wasInRift;
_wasInRift = inRift;
inRift = noone;
with (objS4NewRiftNokill){
    if (collision_rectangle(x-12*image_xscale*dcos(image_angle), y-12*image_xscale*dsin(image_angle), x+12*image_xscale*dcos(image_angle)+sprite_height*dsin(image_angle), y+sprite_height*dcos(image_angle)+12*image_xscale*dsin(image_angle), objPlayer, true, true) != noone || collision_ellipse(x-12*image_xscale*dcos(image_angle) - 6*dsin(image_angle), y-12*image_xscale*dsin(image_angle) - 6*dcos(image_angle), x+12*image_xscale*dcos(image_angle) + 6*dsin(image_angle), y+12*image_xscale*dsin(image_angle) + 6*dcos(image_angle), objPlayer, true, true) != noone || collision_ellipse(x+(sprite_height-6)*dsin(image_angle) - 12*image_xscale*dcos(image_angle), y+(sprite_height-6)*dcos(image_angle) - 12*image_xscale*dsin(image_angle), x+(sprite_height+6)*dsin(image_angle)+12*image_xscale*dcos(image_angle), y+(sprite_height+6)*dcos(image_angle) + 12*image_xscale*dsin(image_angle), objPlayer, true, true) != noone){
        other.inRift = id;
    }
}

if (_wasInRift == noone &amp;&amp; inRift != noone){
    repeat(irandom_range(5, 7)){
        with (instance_create(x, y, objMakerCirclePart)){
            color = c_white;
            direction = point_direction(other.xprevious, other.yprevious, other.x+hspeed, other.y+vspeed) + irandom_range(167, 195);
            gravity = random_range(0.06, 0.11);
            speed = random_range(3.7, 5.5);
            rad = random_range(7, 10);
            rift = true;
            //failsafe
            if (sign (vspeed) != sign(other.yprevious - (other.inRift.bbox_top + other.inRift.sprite_height/2)))
                vspeed *= -1;
        }
    }
}
*/

// Co-op Teleport gimmick
if (global.playerPower == 1 &amp;&amp; !instance_exists(objMakerCoopDestination)){
    instance_create(x, y, objMakerCoopDestination);
}

// Speed fields
if (!vinespeed){
    maxSpeed = 3;
    if (place_meeting(x, y, objLowSpeedField)) {
        maxSpeed = 1;
    } else if (place_meeting(x, y, objHighSpeedField) || highSpeed = true || image_yscale == 2) {
        maxSpeed = 6;
    }
}

//check left/right button presses
var L, R;
if (global.invertControls){
    R = (scrButtonCheck(global.leftButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
    L = (scrButtonCheck(global.rightButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
} else {
    L = (scrButtonCheck(global.leftButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.leftButton)));
    R = (scrButtonCheck(global.rightButton) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(global.rightButton)));
}

var h = 0;

if (!frozen)    //don't move if frozen
{
    if (R)
        h = 1;
    else if (L)
        h = -1;
}

var slipBlockTouching = instance_place(x,y+(1*global.grav),objSlipBlock);   //check if on a slip block

if (iframes &gt; 0){
    iframes -= 1;
}
//vvvvvv kid
sprJump = sprPlayerJump;
sprRunning = sprPlayerRunning;
sprFall = sprPlayerFall;
sprIdle = sprPlayerIdle;

var notOnBlock = (place_free(x,y+(global.grav)) &amp;&amp; !place_meeting(x, y+global.grav, objBetterBlock) &amp;&amp; !riding &amp;&amp; !(room == rStage04New_3 &amp;&amp; place_meeting(x, y+global.grav, objMakerOneWayWall)));
//vine checks
var onVineL = (place_meeting(x-1,y,objWalljumpL) &amp;&amp; notOnBlock);
var onVineR = (place_meeting(x+1,y,objWalljumpR) &amp;&amp; notOnBlock);
var onVineL2 = (place_meeting(x-1,y,objRedVineL) &amp;&amp; notOnBlock);
var onVineR2 = (place_meeting(x+1,y,objRedVineR) &amp;&amp; notOnBlock);
var onVineL3 = (place_meeting(x-1,y,objIceVineL) &amp;&amp; notOnBlock);
var onVineR3 = (place_meeting(x+1,y,objIceVineR) &amp;&amp; notOnBlock);
var onVineL4 = (place_meeting(x-1,y,objBlueVineL) &amp;&amp; notOnBlock);
var onVineR4 = (place_meeting(x+1,y,objBlueVineR) &amp;&amp; notOnBlock);
var onVineL5 = (place_meeting(x-1,y,objYellowVineL) &amp;&amp; notOnBlock);
var onVineR5 = (place_meeting(x+1,y,objYellowVineR) &amp;&amp; notOnBlock);
var onVineL6 = (place_meeting(x-1,y,objPurpleVineL) &amp;&amp; notOnBlock);
var onVineR6 = (place_meeting(x+1,y,objPurpleVineR) &amp;&amp; notOnBlock);
var onVineR7a = (place_meeting(x+1,y,objWhiteVineR) &amp;&amp; notOnBlock &amp;&amp; global.vine7=0);
var onVineL7a = (place_meeting(x-1,y,objWhiteVineL) &amp;&amp; notOnBlock &amp;&amp; global.vine7=0);
var onVineR7b = (place_meeting(x+1,y,objBlackVineR) &amp;&amp; notOnBlock &amp;&amp; global.vine7=1);
var onVineL7b = (place_meeting(x-1,y,objBlackVineL) &amp;&amp; notOnBlock &amp;&amp; global.vine7=1);
var onVineL8 = (place_meeting(x-1,y,objFireVineL) &amp;&amp; notOnBlock);
var onVineR8 = (place_meeting(x+1,y,objFireVineR) &amp;&amp; notOnBlock);
var onAnyVine = (onVineL || onVineR || onVineL2 || onVineR2 || onVineL3 || onVineR3 || onVineL4 || onVineR4 || onVineL5 || onVineR5 || onVineL6 || onVineR6 || onVineL7a || onVineR7a || onVineL7b || onVineR7b || onVineL8 || onVineR8);

if (h != 0)  //player is moving
{
    if (!onVineR &amp;&amp; !onVineL)   //make sure not currently touching a vine
    {
        xScale = h;
    }
    if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
    {
        if (slipBlockTouching == noone) //not touching a slip block, move immediately at full speed
        {
            hspeed = maxSpeed * h;
        }
        else    //touching a slip block, use acceleration
        {
            hspeed += (slipBlockTouching.slip) * h;
            
            if (abs(hspeed) &gt; maxSpeed)
                hspeed = maxSpeed * h;
        }
        
        sprite_index = sprRunning;
        image_speed = 0.5;
    }
}
else    //player is not moving
{
    if (slipBlockTouching == noone) //not touching a slip block, stop immediately
        hspeed = 0;
    else    //touching a slip block, slow down
    {
        if (hspeed &gt; 0)
        {
            hspeed -= slipBlockTouching.slip;
            
            if (hspeed &lt;= 0)
                hspeed = 0;
        }
        else if (hspeed &lt; 0)
        {
            hspeed += slipBlockTouching.slip;
            
            if (hspeed &gt;= 0)
                hspeed = 0;
        }
    }
    
    sprite_index = sprIdle;
    image_speed = 0.2;
}

if (springHForce != 0){
    hspeed += springHForce;
    if (abs(springHForce) &lt; 0.4)
        springHForce = 0;
    else
        springHForce -= 0.4*sign(springHForce);
}
if (vspeed*global.grav &lt; gravity) fallingKid = 0; //Pre-fall animation

if ((!onPlatform &amp;&amp; !onAnyVine &amp;&amp; notOnBlock) || instance_exists(objMakerBubble))    //check if standing on a platform
{
    if((vspeed * global.grav) &lt; -0.05) {sprite_index = sprJump;}
    else if((vspeed * global.grav) &gt;= -0.05) {
        if (fallingKid &lt; 6){
            sprite_index = sprPlayerPreFall;
            image_index = fallingKid;
            fallingKid += 0.5;
        }else{
            sprite_index = sprFall;
            image_speed = 0.5; //in case the player is falling w/o moving horizontally, which happens all the time
        }
    }
}
else
{
    if (!place_meeting(x,y+(4*global.grav),objPlatform) &amp;&amp; !(room == rStage04New_3 &amp;&amp; place_meeting(x, y+global.grav, objMakerOneWayWall))) {onPlatform = false;}
}

if (image_yscale == 2){
    maxVspeed = 15.75;
}else{
    maxVspeed = 9;
}
var _maxVspeedReal = maxVspeed;
if (gravity &lt; 0.4){
    _maxVspeedReal *= lerp(abs(gravity)/0.4, 1, 0.5);
}
if (instance_exists(parachute)){_maxVspeedReal *= 2.5/9;}

if (global.grav*vspeed &gt; _maxVspeedReal) {vspeed = global.grav*_maxVspeedReal;} //check if moving vertically faster than max speed

if (reverseCoyoteFrames &gt; 0)
    reverseCoyoteFrames --;
if (stage4ZeusTimerPleaseImSoTiredOfThis &gt; 0){
    stage4ZeusTimerPleaseImSoTiredOfThis --;
}

if (!frozen)    //check if frozen before doing anything
{
    if (scrButtonCheckPressed(global.shootButton) &amp;&amp; room != rStage01Kurath &amp;&amp; !(room == rFinalBoss_1 &amp;&amp; place_meeting(x, y-24, objFinalKnightFirework) &amp;&amp; (instance_place(x, y-24, objFinalKnightFirework)).carried)){
        if (room == rStage04New_1 &amp;&amp; (bbox_right &gt; 640 &amp;&amp; bbox_left &lt; 960 &amp;&amp; bbox_top &lt; 160)){
            if (stage4ZeusTimerPleaseImSoTiredOfThis &lt;= 0){
                audio_play_sound(sndS1ZeusShoot, 0, 0);
                stage4ZeusTimerPleaseImSoTiredOfThis = 9;
            }
        }else{
            scrPlayerShoot();
        }
    }
    if (scrButtonCheckPressed(global.jumpButton) &amp;&amp; !onAnyVine &amp;&amp; !instance_exists(objMakerBubble)){
        scrPlayerJump();
    }
    if (scrButtonCheckReleased(global.jumpButton))
        scrPlayerVJump();
    /*
    if (scrButtonCheckPressed(global.suicideButton))
        scrKillPlayer();
    */
}

//Landing on Vine Effect
if (!wasOnVine){
    if (onAnyVine){
        wasOnVine = true;
        if ((onVineL5 || onVineR5)){ //Sticky Vine
            var t_vineTouching;
            t_vineTouching = (xScale == 1 &amp;&amp; instance_place(x + 1, y, objYellowVineR));
            if (t_vineTouching == noone) t_vineTouching = instance_place(x - 1, y, objYellowVineL);
            if (t_vineTouching != noone){
                with (t_vineTouching){
                    audio_sound_pitch(audio_play_sound(sndMakerVineYellowLand, 0, 0), PITCH_FLUCT);
                    //get position of effect
                    var t_effectX;
                    var t_effectY = other.y;
                    if (sprite_index == sprMakerVineStickL){
                        t_effectX = x + 32;
                    }else{
                        t_effectX = x - 8;
                    }
                    t_effect = instance_create(t_effectX, other.y, objMakerStickyEffect);
                    t_effect.sprite_index = sprMakerVineYellowLand;
                    t_effect.image_xscale = sign(t_effect.x - x);
                    if (!place_meeting(x, y-1, object_index)){
                        t_effect.top = max(0, min(10, y - (other.y-10)));
                    }else if (!place_meeting(x, y+1, object_index)){
                        t_effect.bottom = max(0, min(10, y+32 - (other.y+10)));
                    }
                }
            }
        }
        if ((onVineL || onVineR)){ //Guy Vine
            audio_sound_pitch(audio_play_sound(sndMakerVineGreenLand, 0, 0), PITCH_FLUCT);
        }
    }
}

if (!global.playerV){
    scrPlayerWallJumps(); //Changed to a script to un-clutter this step event.
}


//slopes

if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
{
    moveLimit = abs(hspeed);    //sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed,y+vspeed+gravity,objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x,y+vspeed))
        {
            if (global.grav == 1)   //normal
                move_contact_solid(270,abs(vspeed));
            else    //flipped
                move_contact_solid(90,abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x,y+(global.grav)) &amp;&amp; place_free(x,y))  //snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //moving down a slope
    if (!notOnBlock)
    {
        var onSlope = (place_meeting(x,y+(global.grav),objSlope));    //treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //check how far we should move down
            while ((!place_meeting(x+hTest,y-ySlope+(global.grav),objSlope) || (onSlope &amp;&amp; !place_meeting(x+hTest,y-ySlope+(global.grav),objBlock))) &amp;&amp; ySlope*global.grav &gt; -floor(moveLimit*(hTest/hspeed)))
            {
                ySlope -= global.grav;
            }
            
            //check if we actually need to move down
            if (place_meeting(x+hTest,y-ySlope+(global.grav),objSlope) || (onSlope &amp;&amp; place_meeting(x+hTest,y-ySlope+(global.grav),objBlock)))
            {
                if (ySlope != 0 &amp;&amp; !place_meeting(x+hTest,y-ySlope,objBlock))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //moving up a slope
    if (place_meeting(x+hspeed,y,objSlope))
    {
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //check how far we have to move up
            while (place_meeting(x+hTest,y-ySlope,objSlope) &amp;&amp; ySlope*global.grav &lt; floor(moveLimit*(hTest/hspeed)))
            {
                ySlope += global.grav;
            }
            
            //check if we actually need to move up
            if (place_free(x+hTest,y-ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlayerKiller">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scrKillPlayer();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!scrIsBetterPlatform(other) &amp;&amp; !scrIsBetterBlock(other)){
    if (global.grav == 1)   //normal
    {
        if (y-vspeed/2 &lt;= other.y)
        {
            if (other.vspeed &gt;= 0)
            {
                y = other.y-9;
                vspeed = other.vspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
    else    //flipped
    {
        if (y-vspeed/2 &gt;= other.y+other.sprite_height-1)
        {
            if ((other.vspeed*-1) &lt;= 0)
            {
                y = other.y+other.sprite_height+8;
                vspeed = -1*other.vspeed;
            }
            
            onPlatform = true;
            djump = 1;
        }
    }
    if (vspeed*global.grav &gt; 3*abs(gravity)){
        audio_play_sound(sndMakerKidLand, 0, 0);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBetterBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Push out to avoid colliding with objects embedded in Better Blocks

PhSpd = (x - xprevious);
PvSpd = (y - yprevious);
with (other){
    event_user(0);
    event_user(1);
    event_user(2);
}

if (springHForce != 0 &amp;&amp; place_meeting(x + springHForce, y, other)){
    springHForce = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBlock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!scrIsBetterBlock(other)){
    if (!place_free(x+hspeed,y))
    {
        if (global.grav == 1)   //normal
        {
            if(hspeed &lt;= 0){move_contact_solid(180,abs(hspeed));}
            if(hspeed &gt; 0){move_contact_solid(0,abs(hspeed));}
        }
        else    //flipped
        {
            if(hspeed &lt; 0){move_contact_solid(180,abs(hspeed));}
            if(hspeed &gt;= 0){move_contact_solid(0,abs(hspeed));}
        }
        hspeed = 0;
    }
     
    if (!place_free(x,y+vspeed))
    {
        if (global.grav == 1)   //normal
        {
            if(vspeed &lt;= 0){move_contact_solid(90,abs(vspeed));}
            if(vspeed &gt; 0){
                move_contact_solid(270,abs(vspeed));
                djump=1;
                if (coopTeleportUses &lt;= 0){
                    coopTeleportUses = 1;
                    if (global.playerPower == 1)
                        audio_play_sound(sndMakerCoopTeleportReplenish, 0, 0);
                }
                if (sprite_index == sprPlayerFall) image_index = 7;
            }
        }
        else    //flipped
        {
            if(vspeed &lt;= 0){
                move_contact_solid(90,abs(vspeed));
                djump=1;
                if (coopTeleportUses &lt;= 0){
                    coopTeleportUses = 1;
                    if (global.playerPower == 1)
                        audio_play_sound(sndMakerCoopTeleportReplenish, 0, 0);
                }
                if (sprite_index == sprPlayerFall) image_index = 7;
            }
            if(vspeed &gt; 0){move_contact_solid(270,abs(vspeed));}
        }
        
        if (sign(vspeed) == global.grav &amp;&amp; (parachute != noone &amp;&amp; room != rStage04New_1)){
            if (instance_exists(parachute)){
                parachute.state = 2;
                parachute.hspeed = 3*dcos(parachute.image_angle + 90);
                parachute.vspeed = -1.8*sign(parachute.flipAmt);
                parachute.curveDir = -sign(parachute.hspeed);
                parachute.flipping = false;
                if (parachute.curveDir == 0){
                    parachute.curveDir = 1;
                }
                audio_play_sound(sndMakerParachuteLost, 0, 0);
            }
            parachute = noone;
        }
        if (vspeed*global.grav &gt; 2*abs(gravity)){
            audio_play_sound(sndMakerKidLand, 0, 0);
        }
        vspeed = 0;
    }
    
    if (!place_free(x+hspeed,y+vspeed)) {hspeed = 0;}
    
    if (springHForce != 0 &amp;&amp; place_meeting(x + springHForce, y, other)){
        springHForce = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Spaghetti fix for objS4NewDraw
if (scrGetRoomNum(room) &gt;= scrGetRoomNum(rStage04New_1) &amp;&amp; scrGetRoomNum(room) &lt;= scrGetRoomNum(rStage04New_4)){
    visible = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw the player
if (global.screenshotMode){exit;}
var drawX = round(x);
var drawY = round(y);
//.50 valign visual glitch fix

if (global.grav == -1 &amp;&amp; !global.dotkid)      //need to draw the player a pixel off in the y-axis when flipped for some reason
    drawY += 1;
if (image_yscale == 0.5) //fix the player being drawn one pixel too low
    drawY --;
if (global.dotkid){
    if (global.playerV){
        draw_sprite_ext(sprDotkidOutlinedV,0,drawX,drawY,image_xscale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
    } else {
        draw_sprite_ext(sprDotkidOutlined,0,drawX,drawY,image_xscale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
    }
}else{
    var t_spr = sprite_index;
    if (global.playerPower == 2){
        switch(sprite_index){
            case sprPlayerIdle:
                t_spr = sprTelePlayerIdle;
                break;
            case sprPlayerRunning:
                t_spr = sprTelePlayerRunning;
                break;
            case sprPlayerJump:
                t_spr = sprTelePlayerJump;
                break;
            case sprPlayerPreFall:
                t_spr = sprTelePlayerPreFall;
                break;
            case sprPlayerFall:
                t_spr = sprTelePlayerFall;
                break;
        }
    }
    draw_sprite_ext(t_spr,image_index,drawX,drawY,image_xscale*xScale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
}

//draw the player's hitbox
if (global.debugShowHitbox){
    draw_sprite_ext(mask_index,image_index,x,y,image_xscale,image_yscale,image_angle,image_blend,image_alpha*0.8);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
